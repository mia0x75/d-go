{{ template "default" . }}
{{ define "special" }}
	{{/* Dashboard Core */}}
	<link href="/assets/css/dashboard.css" rel="stylesheet" />
	<script src="/assets/js/dashboard.js"></script>
	{{/* c3.js Charts Plugin */}}
	<link href="/assets/plugins/charts-c3/plugin.css" rel="stylesheet" />
	<script src="/assets/plugins/charts-c3/plugin.js"></script>
	{{/* Google Maps Plugin */}}
	<link href="/assets/plugins/maps-google/plugin.css" rel="stylesheet" />
	<script src="/assets/plugins/maps-google/plugin.js"></script>
	{{/* Input Mask Plugin */}}
	<script src="/assets/plugins/input-mask/plugin.js"></script>
{{ end }}
{{ define "requirejs-config" }}
<script>
	requirejs.config({
		baseUrl: '..'
	});
</script>
{{ end }}
{{ define "page-title" }}
						<div class="page-header">
							<h1 class="page-title">Documentation</h1>
						</div>
{{ end }}
{{ define "content" }}
						{{/* http://demo.interface.club/limitless/bs4/Template/layout_1/LTR/default/full/d3_lines_basic.html */}}
						<div class="row">
							<div class="col-lg-3 order-lg-1 mb-4">
								<!-- Getting started -->
								<div class="list-group list-group-transparent mb-0">
									<a href="../docs/index.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-flag"></i></span>Introduction</a>
								</div>
								<!-- Components -->
								<div class="list-group list-group-transparent mb-0">
									<a href="../docs/alerts.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-alert-triangle"></i></span>Alerts</a>
									<a href="../docs/avatars.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-user"></i></span>Avatars</a>
									<a href="../docs/buttons.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-plus-square"></i></span>Buttons</a>
									<a href="../docs/colors.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-feather"></i></span>Colors</a>
									<a href="../docs/cards.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-image"></i></span>Cards</a>
									<a href="../docs/charts.html" class="list-group-item list-group-item-action active"><span class="icon mr-3"><i class="fe fe-pie-chart"></i></span>Charts</a>
									<a href="../docs/form-components.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-check-square"></i></span>Form components</a>
									<a href="../docs/tags.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-tag"></i></span>Tags</a>
									<a href="../docs/typography.html" class="list-group-item list-group-item-action"><span class="icon mr-3"><i class="fe fe-type"></i></span>Typography</a>
								</div>
							</div>
							<div class="col-lg-9">
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<h2 class="mt-0 mb-4">Charts</h2>
											<div class="card">
												<div class="card-header">
													<h3 class="card-title">Line chart</h3>
												</div>
												<div class="card-body">
													<div id="linechart1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['c3'], function (c3) {
													var chart = c3.generate({
														bindto: '#linechart1', // id of chart wrapper
														data: {
															columns: [
																// each columns data
																['data1', 7.0, 6.9, 9.5, 14.5, 18.4, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6],
																['data2', 3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8]
															],
															labels: true,
															type: 'line', // default type of chart
															colors: {
																'data1': tabler.colors["blue"],
																'data2': tabler.colors["green"]
															},
															names: {
																// name of each serie
																'data1': 'Tokyo',
																'data2': 'London'
															}
														},
														axis: {
															x: {
																type: 'category',
																// name of each category
																categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']
															},
														},
														legend: {
															show: false, //hide legend
														},
														padding: {
															bottom: 0,
															top: 0
														},
													});
												});
											</script>
										</div>
									</div>
								</div>
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* https://stackoverflow.com/questions/44164912/d3-gauge-chart-with-labels-and-percentages */}}
													<h3 class="card-title">Gauge chart with labels and percentages - 1</h3>
												</div>
												<div class="card-body">
													<div id="chart-wrapper2" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3', 'c3'], function (d3, c3) {
													var width = 712, height = 300;
													var data = [
														{ value: 45, label: "label_1", color: '#ff0000' },
														{ value: 33, label: "label_2", color: '#00ff00' },
														{ value: 66, label: "label_3", color: '#0000ff' },
														{ value: 50, label: "label_4", color: '#ffff00' },
														{ value: 90, label: "label_5", color: '#ff0099' }
													];
													var arcSize = (6 * height / 100);
													var innerRadius = arcSize * 3;
													var svg = d3.select('#chart-wrapper2').append('svg')
														.attr('width', width)
														.attr('height', height)
													var arcs = data.map(function (obj, i) {
														return d3.arc().innerRadius(i * arcSize + innerRadius).outerRadius((i + 1) * arcSize - (height / 100) + innerRadius);
													});
													var arcsGrey = data.map(function (obj, i) {
														return d3.arc().innerRadius(i * arcSize + (innerRadius + ((arcSize / 2) - 2))).outerRadius((i + 1) * arcSize - ((arcSize / 2)) + (innerRadius));
													});
													var pieData = data.map(function (obj, i) {
														return [
															{ value: obj.value * 0.75, arc: arcs[i], object: obj },
															{ value: (100 - obj.value) * 0.75, arc: arcsGrey[i], object: obj },
															{ value: 100 * 0.25, arc: arcs[i], object: obj }];
													});
													var pie = d3.pie()
														.sort(null)
														.value(d => d.value)
													var g = svg.selectAll('g')
														.data(pieData)
														.enter()
														.append('g')
														.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ') rotate(180)')
														.attr('fill-opacity', (d, i) => 2 / (i + 1))
													var gText = svg.selectAll('g.textClass').data([{}]).enter()
														.append('g')
														.classed('textClass', true)
														.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ') rotate(180)');
													g.selectAll('path').data(d => { return pie(d) }).enter().append('path').attr('d', d => { return d.data.arc(d) })
														.attr('fill', (d, i) => i == 0 ? 'blue' : 'none')
													svg.selectAll('g').each(function (d, index) {
														var el = d3.select(this);
														el.selectAll('path').each((r, i) => {
															var obj = r.data.object;
															if (i == 1) {
																var centroid = r.data.arc.centroid({ startAngle: r.startAngle + 0.05, endAngle: r.startAngle + 0.001 + 0.05 })
																g.append('text')
																	.attr('font-size', ((5 * height) / 100))
																	.attr('dominant-baseline', 'central')
																	.attr('alignment-baseline', 'middle')
																	.append("textPath")
																	.attr("textLength", function (d, i) {
																		return 0;
																	})
																	.attr("xlink:href", "#Text" + obj.label)
																	.attr("startOffset", '5')
																	.attr("dy", '-3em')
																	.text(obj.value + '%');
															}
															if (i === 0) {
																var centroidText = r.data.arc.centroid({
																	startAngle: r.startAngle,
																	endAngle: r.startAngle
																});
																gText.append('text')
																	.attr('font-size', ((5 * height) / 100))
																	.text(obj.label)
																	.attr('transform', "translate(" + (centroidText[0] - ((1.5 * height) / 100)) + "," + (centroidText[1] + ") rotate(" + (180) + ")"))
																	.attr('dominant-baseline', 'central');
															}
														})
													})
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* https://stackoverflow.com/questions/44164912/d3-gauge-chart-with-labels-and-percentages */}}
													<h3 class="card-title">Gauge chart with labels and percentages - 2</h3>
												</div>
												<div class="card-body">
													<div id="chart-wrapper3" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var width = 712, height = 300;
													var arcSize = (6 * height / 100);
													var innerRadius = arcSize * 3;
													var data = [
														{ value: 45, label: "label_1", color: '#ff0000' },
														{ value: 33, label: "label_2", color: '#00ff00' },
														{ value: 66, label: "label_3", color: '#0000ff' },
														{ value: 50, label: "label_4", color: '#ffff00' },
														{ value: 90, label: "label_5", color: '#ff0099' }
													];
													function render() {
														var svg = d3.select('#chart-wrapper3').append('svg').attr('width', width).attr('height', height);
														var arcs = data.map(function (obj, i) {
															return d3.arc().innerRadius(i * arcSize + innerRadius).outerRadius((i + 1) * arcSize - (height / 100) + innerRadius);
														});
														var arcsGrey = data.map(function (obj, i) {
															return d3.arc().innerRadius(i * arcSize + (innerRadius + ((arcSize / 2) - 2))).outerRadius((i + 1) * arcSize - ((arcSize / 2)) + (innerRadius));
														});
														var pieData = data.map(function (obj, i) {
															return [
																{ value: obj.value * 0.75, arc: arcs[i], object: obj },
																{ value: (100 - obj.value) * 0.75, arc: arcsGrey[i], object: obj },
																{ value: 100 * 0.25, arc: arcs[i], object: obj }];
														});
														var pie = d3.pie().sort(null).value(function (d) {
															return d.value;
														});
														var g = svg.selectAll('g').data(pieData).enter()
															.append('g')
															.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ') rotate(180)');
														var gText = svg.selectAll('g.textClass').data([{}]).enter()
															.append('g')
															.classed('textClass', true)
															.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ') rotate(180)');
														g.selectAll('path').data(function (d) {
															return pie(d);
														}).enter().append('path')
															.attr('id', function (d, i) {
																if (i == 1) {
																	return "Text" + d.data.object.label
																}
															})
															.attr('d', function (d) {
																return d.data.arc(d);
															}).attr('fill', function (d, i) {
																return i == 0 ? d.data.object.color : i == 1 ? '#D3D3D3' : 'none';
															});
														svg.selectAll('g').each(function (d, index) {
															var el = d3.select(this);
															var path = el.selectAll('path').each(function (r, i) {
																var obj = r.data.object;
																if (i === 1) {
																	var centroid = r.data.arc.centroid({
																		startAngle: r.startAngle + 0.05,
																		endAngle: r.startAngle + 0.001 + 0.05
																	});
																	g.append('text')
																		.attr('font-size', ((5 * height) / 100))
																		.attr('dominant-baseline', 'central')
																		.append("textPath")
																		.attr("textLength", function (d, i) {
																			return 0;
																		})
																		.attr("xlink:href", "#Text" + obj.label)
																		.attr("startOffset", '5')
																		.attr("dy", '-3em')
																		.text(obj.value + '%');
																}
																if (i === 0) {
																	var centroidText = r.data.arc.centroid({
																		startAngle: r.startAngle,
																		endAngle: r.startAngle
																	});
																	gText.append('text')
																		.attr('font-size', ((5 * height) / 100))
																		.text(obj.label)
																		.attr('transform', "translate(" + (centroidText[0] - ((1.5 * height) / 100)) + "," + (centroidText[1] + ") rotate(" + (180) + ")"))
																		.attr('dominant-baseline', 'central');
																}
															});
														});
													}
													render()
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://bl.ocks.org/brattonc/5e5ce9beee483220e2f6 */}}
													<h3 class="card-title">Gauge chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="chart-wrapper4" style="height: auto">
														<svg id="lfg1" width="97%" height="250"></svg>
														<svg id="lfg2" width="19%" height="200"></svg>
														<svg id="lfg3" width="19%" height="200"></svg>
														<svg id="lfg4" width="19%" height="200"></svg>
														<svg id="lfg5" width="19%" height="200"></svg>
														<svg id="lfg6" width="19%" height="200"></svg>
													</div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var gauge1 = loadLiquidFillGauge("lfg1", 55);
													var config1 = liquidFillGaugeDefaultSettings();
													config1.circleColor = "#FF7777";
													config1.textColor = "#FF4444";
													config1.waveTextColor = "#FFAAAA";
													config1.waveColor = "#FFDDDD";
													config1.circleThickness = 0.2;
													config1.textVertPosition = 0.2;
													config1.waveAnimateTime = 1000;
													var gauge2 = loadLiquidFillGauge("lfg2", 28, config1);
													var config2 = liquidFillGaugeDefaultSettings();
													config2.circleColor = "#D4AB6A";
													config2.textColor = "#553300";
													config2.waveTextColor = "#805615";
													config2.waveColor = "#AA7D39";
													config2.circleThickness = 0.1;
													config2.circleFillGap = 0.2;
													config2.textVertPosition = 0.8;
													config2.waveAnimateTime = 2000;
													config2.waveHeight = 0.3;
													config2.waveCount = 1;
													var gauge3 = loadLiquidFillGauge("lfg3", 60.1, config2);
													var config3 = liquidFillGaugeDefaultSettings();
													config3.textVertPosition = 0.8;
													config3.waveAnimateTime = 5000;
													config3.waveHeight = 0.15;
													config3.waveAnimate = false;
													config3.waveOffset = 0.25;
													config3.displayPercent = false;
													var gauge4 = loadLiquidFillGauge("lfg4", 50, config3);
													var config4 = liquidFillGaugeDefaultSettings();
													config4.circleThickness = 0.15;
													config4.circleColor = "#808015";
													config4.textColor = "#555500";
													config4.waveTextColor = "#FFFFAA";
													config4.waveColor = "#AAAA39";
													config4.textVertPosition = 0.8;
													config4.waveAnimateTime = 1000;
													config4.waveHeight = 0.05;
													config4.waveAnimate = true;
													config4.waveRise = false;
													config4.waveHeightScaling = false;
													config4.waveOffset = 0.25;
													config4.textSize = 0.75;
													config4.waveCount = 3;
													var gauge5 = loadLiquidFillGauge("lfg5", 60.44, config4);
													var config5 = liquidFillGaugeDefaultSettings();
													config5.circleThickness = 0.4;
													config5.circleColor = "#6DA398";
													config5.textColor = "#0E5144";
													config5.waveTextColor = "#6DA398";
													config5.waveColor = "#246D5F";
													config5.textVertPosition = 0.52;
													config5.waveAnimateTime = 5000;
													config5.waveHeight = 0;
													config5.waveAnimate = false;
													config5.waveCount = 2;
													config5.waveOffset = 0.25;
													config5.textSize = 1.2;
													config5.minValue = 30;
													config5.maxValue = 150
													config5.displayPercent = false;
													var gauge6 = loadLiquidFillGauge("lfg6", 120, config5);

													function NewValue() {
														if (Math.random() > .5) {
															return Math.round(Math.random() * 100);
														} else {
															return (Math.random() * 100).toFixed(1);
														}
													}
													function liquidFillGaugeDefaultSettings() {
														return {
															minValue: 0, // The gauge minimum value.
															maxValue: 100, // The gauge maximum value.
															circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
															circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
															circleColor: "#178BCA", // The color of the outer circle.
															waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
															waveCount: 1, // The number of full waves per width of the wave circle.
															waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
															waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.
															waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
															waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
															waveAnimate: true, // Controls if the wave scrolls or is static.
															waveColor: "#178BCA", // The color of the fill wave.
															waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
															textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
															textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%
															valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
															displayPercent: true, // If true, a % symbol is displayed after the value.
															textColor: "#045681", // The color of the value text when the wave does not overlap it.
															waveTextColor: "#A4DBf8" // The color of the value text when the wave overlaps it.
														};
													}

													function loadLiquidFillGauge(elementId, value, config) {
														if (config == null) config = liquidFillGaugeDefaultSettings();

														var gauge = d3.select("#" + elementId);
														var radius = Math.min(parseInt(gauge.style("width")), parseInt(gauge.style("height"))) / 2;
														var locationX = parseInt(gauge.style("width")) / 2 - radius;
														var locationY = parseInt(gauge.style("height")) / 2 - radius;
														var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;

														var waveHeightScale;
														if (config.waveHeightScaling) {
															waveHeightScale = d3.scaleLinear()
																.range([0, config.waveHeight, 0])
																.domain([0, 50, 100]);
														} else {
															waveHeightScale = d3.scaleLinear()
																.range([config.waveHeight, config.waveHeight])
																.domain([0, 100]);
														}

														var textPixels = (config.textSize * radius / 2);
														var textFinalValue = parseFloat(value).toFixed(2);
														var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
														var percentText = config.displayPercent ? "%" : "";
														var circleThickness = config.circleThickness * radius;
														var circleFillGap = config.circleFillGap * radius;
														var fillCircleMargin = circleThickness + circleFillGap;
														var fillCircleRadius = radius - fillCircleMargin;
														var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);

														var waveLength = fillCircleRadius * 2 / config.waveCount;
														var waveClipCount = 1 + config.waveCount;
														var waveClipWidth = waveLength * waveClipCount;

														// Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
														var textRounder = function (value) { return Math.round(value); };
														if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
															textRounder = function (value) { return parseFloat(value).toFixed(1); };
														}
														if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
															textRounder = function (value) { return parseFloat(value).toFixed(2); };
														}

														// Data for building the clip wave area.
														var data = [];
														for (var i = 0; i <= 40 * waveClipCount; i++) {
															data.push({ x: i / (40 * waveClipCount), y: (i / (40)) });
														}

														// Scales for drawing the outer circle.
														var gaugeCircleX = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 1]);
														var gaugeCircleY = d3.scaleLinear().range([0, radius]).domain([0, radius]);

														// Scales for controlling the size of the clipping path.
														var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
														var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);

														// Scales for controlling the position of the clipping path.
														var waveRiseScale = d3.scaleLinear()
															// The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
															// such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
															// circle at 100%.
															.range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])
															.domain([0, 1]);
														var waveAnimateScale = d3.scaleLinear()
															.range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
															.domain([0, 1]);

														// Scale for controlling the position of the text within the gauge.
														var textRiseScaleY = d3.scaleLinear()
															.range([fillCircleMargin + fillCircleRadius * 2, (fillCircleMargin + textPixels * 0.7)])
															.domain([0, 1]);

														// Center the gauge within the parent SVG.
														var gaugeGroup = gauge.append("g")
															.attr('transform', 'translate(' + locationX + ',' + locationY + ')');

														// Draw the outer circle.
														var gaugeCircleArc = d3.arc()
															.startAngle(gaugeCircleX(0))
															.endAngle(gaugeCircleX(1))
															.outerRadius(gaugeCircleY(radius))
															.innerRadius(gaugeCircleY(radius - circleThickness));
														gaugeGroup.append("path")
															.attr("d", gaugeCircleArc)
															.style("fill", config.circleColor)
															.attr('transform', 'translate(' + radius + ',' + radius + ')');

														// Text where the wave does not overlap.
														var text1 = gaugeGroup.append("text")
															.text(textRounder(textStartValue) + percentText)
															.attr("class", "liquidFillGaugeText")
															.attr("text-anchor", "middle")
															.attr("font-size", textPixels + "px")
															.style("fill", config.textColor)
															.attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

														// The clipping wave area.
														var clipArea = d3.area()
															.x(function (d) { return waveScaleX(d.x); })
															.y0(function (d) { return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI)); })
															.y1(function (d) { return (fillCircleRadius * 2 + waveHeight); });
														var waveGroup = gaugeGroup.append("defs")
															.append("clipPath")
															.attr("id", "clipWave" + elementId);
														var wave = waveGroup.append("path")
															.datum(data)
															.attr("d", clipArea)
															.attr("T", 0);

														// The inner circle with the clipping wave attached.
														var fillCircleGroup = gaugeGroup.append("g")
															.attr("clip-path", "url(#clipWave" + elementId + ")");
														fillCircleGroup.append("circle")
															.attr("cx", radius)
															.attr("cy", radius)
															.attr("r", fillCircleRadius)
															.style("fill", config.waveColor);

														// Text where the wave does overlap.
														var text2 = fillCircleGroup.append("text")
															.text(textRounder(textStartValue) + percentText)
															.attr("class", "liquidFillGaugeText")
															.attr("text-anchor", "middle")
															.attr("font-size", textPixels + "px")
															.style("fill", config.waveTextColor)
															.attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

														// Make the value count up.
														if (config.valueCountUp) {
															var textTween = function () {
																var node = d3.select(this);
																var i = d3.interpolate(this.textContent, parseFloat(textFinalValue).toFixed(2));
																return function (t) {
																	node.text(textRounder(i(t)) + percentText);
																}
															};
															text1.transition()
																.duration(config.waveRiseTime)
																.tween("text", textTween);
															text2.transition()
																.duration(config.waveRiseTime)
																.tween("text", textTween);
														}

														// Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
														var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
														if (config.waveRise) {
															waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
																.transition()
																.duration(config.waveRiseTime)
																.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
																.on("start", function () { wave.attr('transform', 'translate(1,0)'); }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
														} else {
															waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
														}

														if (config.waveAnimate) animateWave();

														function animateWave() {
															wave.attr('transform', 'translate(' + waveAnimateScale(wave.attr('T')) + ',0)');
															var w = wave.transition()
																.duration(config.waveAnimateTime * (1 - wave.attr('T')))
																.ease(d3.easeLinear)
																.attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
																.attr('T', 1)
																.on('end', function () {
																	wave.attr('T', 0);
																	animateWave(config.waveAnimateTime);
																});
														}
													}
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* https://c3js.org/samples/chart_gauge.html */}}
													<h3 class="card-title">Gauge chart - 2</h3>
												</div>
												<div class="card-body">
													<div id="gc2" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													const width = 712;
													const height = 170;

													const minAngle = -(2.5 * Math.PI / 4);
													const maxAngle = 2.5 * Math.PI / 4;

													const container = d3
														.select("#gc2")
														.append("svg")
														.attr("width", width)
														.attr("height", height);

													const svg = container
														.append("g")
														.attr("transform", "translate(" + width / 2 + "," + (height / 2 + ((200 - height) / 2)) + ")");

													const trackArc = d3
														.arc()
														.innerRadius(98)
														.outerRadius(100)
														.startAngle(minAngle);

													const track = svg
														.append("g")
														.attr("class", "track")
														.append("path")
														.attr("d", trackArc.endAngle(maxAngle))
														.attr('fill-opacity', 0.3);

													const progressArc = d3
														.arc()
														.innerRadius(65)
														.outerRadius(95)
														.startAngle(minAngle);

													const progress = svg.append("g")
														.attr("class", "progress");

													const progressPath = progress.append("path")
														.datum({ endAngle: 0 })
														.attr("d", progressArc)
														.style("fill", function () {
															return "#1ab394"
														});

													function arcTween(newAngle) {
														return function (d) {
															var interpolate = d3.interpolate(d.endAngle, newAngle);
															return function (t) {
																d.endAngle = interpolate(t);
																return progressArc(d);
															};
														};
													}

													function handleClick() {
														progressPath.transition()
															.duration(750)
															.attrTween("d", arcTween(randomAngle()));
													}

													function randomAngle() {
														return (Math.random() * (maxAngle - minAngle)) + minAngle;
													}
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* url */}}
													<h3 class="card-title">Spline chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="splinechart1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['c3'], function (c3) {
													c3.generate({
														bindto: "#splinechart1",
														data: {
															json: [
																{
																	"metricDate": "2016-02-08",
																	"vlp": 9046,
																	"other": 904,
																	"vdp": 10000,
																	"home": 3543
																}, {
																	"metricDate": "2016-02-09",
																	"vdp": 7000,
																	"other": 1103,
																	"home": 3667,
																	"vlp": 9542
																}, {
																	"metricDate": "2016-02-10",
																	"other": 1043,
																	"vlp": 9751,
																	"home": 3681,
																	"vdp": 5000
																}, {
																	"metricDate": "2016-02-11",
																	"other": 1433,
																	"home": 4059,
																	"vdp": 4000,
																	"vlp": 9924
																}
															],
															type: 'area-spline',
															groups: [['other', 'home', 'vdp', 'vlp']],
															keys: {
																x: 'metricDate',
																value: ["vlp", "home", "vdp", "other"]
															}
														},
														axis: {
															x: {
																type: 'timeseries',
															}
														}
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/mbostock/3886394 */}}
													<h3 class="card-title">Stacked bar chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="sbc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var svg = d3.select("#sbc1").append("svg").attr("width", 712).attr("height", 300),
														margin = { top: 20, right: 60, bottom: 30, left: 40 },
														width = +svg.attr("width") - margin.left - margin.right,
														height = +svg.attr("height") - margin.top - margin.bottom,
														g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var x = d3.scaleBand()
														.rangeRound([0, width])
														.padding(0.1)
														.align(0.1);

													var y = d3.scaleLinear()
														.rangeRound([height, 0]);

													var z = d3.scaleOrdinal()
														.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													var stack = d3.stack()
														.offset(d3.stackOffsetExpand);

													var dataset = d3.csv("/demo/population.csv", function (data) {
														return data;
													});
													dataset.then(function (data) {
														x.domain(data.map(function (d) { return d.State; }));
														z.domain(data.columns.slice(1));
														var serie = g.selectAll(".serie")
															.data(stack.keys(data.columns.slice(1))(data))
															.enter().append("g")
															.attr("class", "serie")
															.attr("fill", function (d) { return z(d.key); });

														serie.selectAll("rect")
															.data(function (d) { return d; })
															.enter().append("rect")
															.attr("x", function (d) { return x(d.data.State); })
															.attr("y", function (d) { return y(d[1]); })
															.attr("height", function (d) { return y(d[0]) - y(d[1]); })
															.attr("width", x.bandwidth());

														g.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x));

														g.append("g")
															.attr("class", "axis axis--y")
															.call(d3.axisLeft(y).ticks(10, "%"));

														var legend = serie.append("g")
															.attr("class", "legend")
															.attr("transform", function (d) { var d = d[d.length - 1]; return "translate(" + (x(d.data.State) + x.bandwidth()) + "," + ((y(d[0]) + y(d[1])) / 2) + ")"; });

														legend.append("line")
															.attr("x1", -6)
															.attr("x2", 6)
															.attr("stroke", "#000");

														legend.append("text")
															.attr("x", 9)
															.attr("dy", "0.35em")
															.attr("fill", "#000")
															.style("font", "10px sans-serif")
															.text(function (d) { return d.key; });
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/mbostock/3886208 */}}
													<h3 class="card-title">Stacked bar chart - 2</h3>
												</div>
												<div class="card-body">
													<div id="sbc2" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var svg = d3.select("#sbc2").append("svg").attr("width", 712).attr("height", 300),
														margin = { top: 20, right: 60, bottom: 30, left: 40 },
														width = +svg.attr("width") - margin.left - margin.right,
														height = +svg.attr("height") - margin.top - margin.bottom,
														g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var x = d3.scaleBand()
														.rangeRound([0, width])
														.padding(0.1)
														.align(0.1);

													var y = d3.scaleLinear()
														.rangeRound([height, 0]);

													var z = d3.scaleOrdinal()
														.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													var dataset = d3.csv("/demo/population.csv", function (data) {
														return data;
													});
													var keys;
													dataset.then(function (data) {
														keys = data.columns.slice(1);
														var c = data.map(function (d) {
															var total = 0;
															for (i = 1; i < data.columns.length; ++i) {
																total += d[data.columns[i]] = +d[data.columns[i]];
															}
															d.Total = total;
															return d;
														});
														return c;
													}).then(function (data) {
														data.sort(function (a, b) {
															return b.Total - a.Total;
														});
														var max = d3.max(data, function (d) {
															return d.Total
														});
														y.domain([0, max]);
														x.domain(data.map(function (d) { return d.State; }));
														z.domain(keys);
														var serie = g.selectAll(".serie")
															.data(d3.stack().keys(keys)(data))
															.enter().append("g")
															.attr("class", "serie")
															.attr("fill", function (d) { return z(d.key); });

														serie.selectAll("rect")
															.data(function (d) { return d; })
															.enter().append("rect")
															.attr("x", function (d) { return x(d.data.State); })
															.attr("y", function (d) { return y(d[1]); })
															.attr("height", function (d) { return y(d[0]) - y(d[1]); })
															.attr("width", x.bandwidth());

														g.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x));

														g.append("g")
															.attr("class", "axis axis--y")
															.call(d3.axisLeft(y).ticks(null, "s"))
															.append("text")
															.attr("x", 2)
															.attr("y", y(y.ticks().pop()) + 0.5)
															.attr("dy", "0.32em")
															.attr("fill", "#000")
															.attr("font-weight", "bold")
															.attr("text-anchor", "start")
															.text("Population");

														var legend = g.append("g")
															.attr("font-family", "sans-serif")
															.attr("font-size", 10)
															.attr("text-anchor", "end")
															.selectAll("g")
															.data(keys.slice().reverse())
															.enter().append("g")
															.attr("transform", function (d, i) { return "translate(0," + i * 20 + ")"; });

														legend.append("rect")
															.attr("x", width - 19)
															.attr("width", 19)
															.attr("height", 19)
															.attr("fill", z);

														legend.append("text")
															.attr("x", width - 24)
															.attr("y", 9.5)
															.attr("dy", "0.32em")
															.text(function (d) { return d; });
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/HarryStevens/dea8fdcdae7401ab486bfc7fcc9f6882 */}}
													<h3 class="card-title">Stacked bar chart - 3</h3>
												</div>
												<div class="card-body">
													<div id="sbc3" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var svg = d3.select("#sbc3").append("svg").attr("width", 712).attr("height", 600),
														margin = { top: 20, right: 60, bottom: 30, left: 40 },
														width = +svg.attr("width") - margin.left - margin.right,
														height = +svg.attr("height") - margin.top - margin.bottom,
														g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var y = d3.scaleBand()
														.rangeRound([0, height])
														.padding(0.1)
														.align(0.1);

													var x = d3.scaleLinear()
														.rangeRound([0, width]);

													var z = d3.scaleOrdinal()
														.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													var stack = d3.stack()
														.offset(d3.stackOffsetExpand);

													var dataset = d3.csv("/demo/population.csv", function (data) {
														return data;
													});
													dataset.then(function (data) {
														y.domain(data.map(function (d) { return d.State; }));
														z.domain(data.columns.slice(1));
														var serie = g.selectAll(".serie")
															.data(stack.keys(data.columns.slice(1))(data))
															.enter().append("g")
															.attr("class", "serie")
															.attr("fill", function (d) { return z(d.key); });

														serie.selectAll("rect")
															.data(function (d) { return d; })
															.enter().append("rect")
															.attr("x", function (d) { return x(d[0]); })
															.attr("y", function (d) { return y(d.data.State); })
															.attr("height", y.bandwidth())
															.attr("width", function (d) { return x(d[1]) - x(d[0]); });

														g.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x).ticks(10, "%"));

														g.append("g")
															.attr("class", "axis axis--y")
															.attr("transform", "translate(0,0)")
															.call(d3.axisLeft(y));
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/Andrew-Reid/0aedd5f3fb8b099e3e10690bd38bd458 */}}
													<h3 class="card-title">Stacked bar chart - 4</h3>
												</div>
												<div class="card-body">
													<div id="sbc4" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var svg = d3.select("#sbc4").append("svg").attr("width", 712).attr("height", 600),
														margin = { top: 20, right: 60, bottom: 30, left: 40 },
														width = +svg.attr("width") - margin.left - margin.right,
														height = +svg.attr("height") - margin.top - margin.bottom,
														g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var x = d3.scaleLinear()
														.rangeRound([0, width]);

													var y = d3.scaleBand()
														.rangeRound([0, height])
														.paddingInner(0.05)
														.align(0.1);

													var z = d3.scaleOrdinal()
														.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													var dataset = d3.csv("/demo/population.csv", function (data) {
														return data;
													});
													var keys;
													dataset.then(function (data) {
														keys = data.columns.slice(1);
														var c = data.map(function (d) {
															var total = 0;
															for (i = 1; i < data.columns.length; ++i) {
																total += d[data.columns[i]] = +d[data.columns[i]];
															}
															d.Total = total;
															return d;
														});
														return c;
													}).then(function (data) {
														data.sort(function (a, b) { return b.Total - a.Total; });
														y.domain(data.map(function (d) { return d.State; }));
														x.domain([0, d3.max(data, function (d) { return d.Total; })]).nice();
														z.domain(keys);

														g.append("g")
															.selectAll("g")
															.data(d3.stack().keys(keys)(data))
															.enter().append("g")
															.attr("fill", function (d) { return z(d.key); })
															.selectAll("rect")
															.data(function (d) { return d; })
															.enter().append("rect")
															.attr("x", function (d) { return x(d[0]); })
															.attr("y", function (d) { return y(d.data.State); })
															.attr("width", function (d) { return x(d[1]) - x(d[0]); })
															.attr("height", y.bandwidth());

														g.append("g")
															.attr("class", "axis")
															.attr("transform", "translate(0,0)")
															.call(d3.axisLeft(y));

														g.append("g")
															.attr("class", "axis")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x).ticks(null, "s"))
															.append("text")
															.attr("y", 2)
															.attr("x", x(x.ticks().pop()) + 0.5)
															.attr("dy", "0.32em")
															.attr("fill", "#000")
															.attr("font-weight", "bold")
															.attr("text-anchor", "start")
															.text("Population")
															.attr("transform", "translate(" + (-width) + ",-10)");

														var legend = g.append("g")
															.attr("font-family", "sans-serif")
															.attr("font-size", 10)
															.attr("text-anchor", "end")
															.selectAll("g")
															.data(keys.slice().reverse())
															.enter().append("g")
															.attr("transform", function (d, i) { return "translate(-50," + (300 + i * 20) + ")"; });

														legend.append("rect")
															.attr("x", width - 19)
															.attr("width", 19)
															.attr("height", 19)
															.attr("fill", z);

														legend.append("text")
															.attr("x", width - 24)
															.attr("y", 9.5)
															.attr("dy", "0.32em")
															.text(function (d) { return d; });
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/mbostock/3887051 */}}
													<h3 class="card-title">Grouped bar chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="gbc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var svg = d3.select("#gbc1").append("svg").attr("width", "712").attr("height", "300"),
														margin = { top: 20, right: 20, bottom: 30, left: 40 },
														width = +svg.attr("width") - margin.left - margin.right,
														height = +svg.attr("height") - margin.top - margin.bottom,
														g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var x0 = d3.scaleBand()
														.rangeRound([0, width])
														.paddingInner(0.1);

													var x1 = d3.scaleBand()
														.padding(0.05);

													var y = d3.scaleLinear()
														.rangeRound([height, 0]);

													var z = d3.scaleOrdinal()
														.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													var dataset = d3.csv("/demo/population.csv", function (data) { return data; });
													var keys;
													dataset.then(function (data) {
														keys = data.columns.slice(1);
														var c = data.map(function (d) {
															var total = 0;
															for (i = 1; i < data.columns.length; ++i) {
																total += d[data.columns[i]] = +d[data.columns[i]];
															}
															d.Total = total;
															return d;
														});
														return c;
													}).then(function (data) {
														x0.domain(data.map(function (d) { return d.State; }));
														x1.domain(keys).rangeRound([0, x0.bandwidth()]);
														y.domain([0, d3.max(data, function (d) { return d3.max(keys, function (key) { return d[key]; }); })]).nice();

														g.append("g")
															.selectAll("g")
															.data(data)
															.enter().append("g")
															.attr("transform", function (d) { return "translate(" + x0(d.State) + ",0)"; })
															.selectAll("rect")
															.data(function (d) { return keys.map(function (key) { return { key: key, value: d[key] }; }); })
															.enter().append("rect")
															.attr("x", function (d) { return x1(d.key); })
															.attr("y", function (d) { return y(d.value); })
															.attr("width", x1.bandwidth())
															.attr("height", function (d) { return height - y(d.value); })
															.attr("fill", function (d) { return z(d.key); });

														g.append("g")
															.attr("class", "axis")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x0));

														g.append("g")
															.attr("class", "axis")
															.call(d3.axisLeft(y).ticks(null, "s"))
															.append("text")
															.attr("x", 2)
															.attr("y", y(y.ticks().pop()) + 0.5)
															.attr("dy", "0.32em")
															.attr("fill", "#000")
															.attr("font-weight", "bold")
															.attr("text-anchor", "start")
															.text("Population");

														var legend = g.append("g")
															.attr("font-family", "sans-serif")
															.attr("font-size", 10)
															.attr("text-anchor", "end")
															.selectAll("g")
															.data(keys.slice().reverse())
															.enter().append("g")
															.attr("transform", function (d, i) { return "translate(0," + i * 20 + ")"; });

														legend.append("rect")
															.attr("x", width - 19)
															.attr("width", 19)
															.attr("height", 19)
															.attr("fill", z);

														legend.append("text")
															.attr("x", width - 24)
															.attr("y", 9.5)
															.attr("dy", "0.32em")
															.text(function (d) { return d; });
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/mbostock/4063318 */}}
													<h3 class="card-title">Calendar chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="hm1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var width = 712,
														height = 160,
														cellSize = Math.floor(width / 53); // cell size
													var margin = { top: 20, right: 60, bottom: 30, left: 15 };

													var percent = d3.format(".1%"),
														format = d3.timeFormat("%Y-%m-%d");

													var color = d3.scaleQuantize()
														.domain([-0.03, 0.03])
														.range(["#f46d43", "#fdae61", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]);

													var svg = d3.select("#hm1").selectAll("svg")
														.data(d3.range(2018, 2019))
														.enter()
														.append("svg")
														.attr("width", width)
														.attr("height", height)
														.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													// svg.append("text")
													// 	.attr("transform", "translate(-6," + cellSize * 3.5 + ")rotate(-90)")
													// 	.style("text-anchor", "middle")
													// 	.attr("dy", -30)
													// 	.text(function (d) { return d; });

													// var rect = svg.selectAll(".day")
													// 	.data(function (d) { return d3.timeDays(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })
													// 	.enter()
													// 	.append("rect")
													// 	.attr("class", "day")
													// 	.style("fill", function (d) { return color(0.01); })
													// 	.style("stoke", "#ccc")
													// 	.attr("width", cellSize - 2)
													// 	.attr("height", cellSize - 2)
													// 	.attr("x", function (d) { return d3.timeWeek.count(d3.timeYear(d), d) * cellSize; })
													// 	.attr("y", function (d) { return d.getDay() * cellSize; })
													// 	.datum(format);
													svg.append("g")
														.attr("fill", "none")
														.attr("stroke", "#ccc")
														.attr("stroke-width", "0.25px")
														.selectAll("path")
														.data(function (d) { return d3.timeMonths(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })
														.enter().append("path")
														.attr("d", function (d) {
															var t1 = new Date(d.getFullYear(), d.getMonth() + 1, 0),
																d0 = d.getDay(), w0 = d3.timeWeek.count(d3.timeYear(d), d);
															d1 = t1.getDay(), w1 = d3.timeWeek.count(d3.timeYear(t1), t1);
															return "M" + (w0 + 1) * cellSize + "," + d0 * cellSize
																+ "H" + w0 * cellSize + "V" + 7 * cellSize
																+ "H" + w1 * cellSize + "V" + (d1 + 1) * cellSize
																+ "H" + (w1 + 1) * cellSize + "V" + 0
																+ "H" + (w0 + 1) * cellSize + "Z";
														});
													// var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
													// months.forEach(function (d, i) {
													// 	x = 4 + (3.5 * i);
													// 	x = x + "em";
													// 	svg.append("text")
													// 		.style("text-anchor", "end")
													// 		.attr("class", "month")
													// 		.attr("dy", "-.25em")
													// 		.attr("dx", x)
													// 		.text(d);
													// });
													// var days = ['', '', '', '', '', '', ''];
													// days.forEach(function (d, i) {
													// 	y = 0.8 + (1.7 * i);
													// 	y = y + "em";
													// 	svg.append("text")
													// 		.style("text-anchor", "end")
													// 		.attr("dy", y)
													// 		.attr("dx", "-1em")
													// 		.text(d);
													// });
													var circle = svg.selectAll(".day")
														.data(function (d) { return d3.timeDays(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })
														.enter()
														.append("circle")
														.attr("class", "day")
														.style("fill", "#eee")
														.attr("r", cellSize / 2 - 1)
														.attr("cx", function (d) { return d3.timeWeek.count(d3.timeYear(d), d) * cellSize + cellSize / 2; })
														.attr("cy", function (d) { return d.getDay() * cellSize + cellSize / 2; })
														.datum(format);

													circle.append("title")
														.text(function (d) { return d; });

													var dataset = d3.csv("/demo/calendar.csv", function (data) {
														return data;
													});
													dataset.then(function (csv) {
														var data = d3.nest()
															.key(function (d) { return d.Date; })
															.rollup(function (d) { return (d[0].Close - d[0].Open) / d[0].Open; })
															.map(csv);
														circle.filter(function (d) {
															// d => yyyy-MM-dd
															return data.has(d);
														})
															.style("fill", function (d) {
																return color(data.get(d));
															})
															.select("title")
															.text(function (d) {
																return d + ": " + data.get(d);
															});
													});

													// var svgContainer = d3.select("#legend").append("svg")
													// 	.attr("width", 800)
													// 	.attr("height", 25);
													// svgContainer.append("text")
													// 	.attr("x", 0)
													// 	.attr("y", 25)
													// 	.text("Faible concentration d'accidents")

													// var rectangle = svgContainer.append("rect")
													// 	.attr("x", 160)
													// 	.attr("y", 10)
													// 	.attr("width", 20)
													// 	.attr("height", 20).attr("fill", "#006837");

													// svgContainer.append("rect")
													// 	.attr("x", 190)
													// 	.attr("y", 10)
													// 	.attr("width", 20)
													// 	.attr("height", 20).attr("fill", "#A6D96A");

													// svgContainer.append("rect")
													// 	.attr("x", 220)
													// 	.attr("y", 10)
													// 	.attr("width", 20)
													// 	.attr("height", 20).attr("fill", "#FEE08B"); svgContainer.append("rect")
													// 		.attr("x", 250)
													// 		.attr("y", 10)
													// 		.attr("width", 20)
													// 		.attr("height", 20).attr("fill", "#A50026");

													// svgContainer.append("text")
													// 	.attr("x", 280)
													// 	.attr("y", 25)
													// 	.text("Forte concentration d'accidents")
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* 
														https://cal-heatmap.com/v2/
														https://github.com/DKirwan/calendar-heatmap
													*/}}
													<h3 class="card-title">Calendar chart - 2</h3>
												</div>
												<div class="card-body">
													<div id="hm2" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var width = 712,
														height = 160,
														cellSize = Math.floor(width / 53); // cell size
													var margin = { top: 20, right: 60, bottom: 30, left: 15 };

													var percent = d3.format(".1%"),
														format = d3.timeFormat("%Y-%m-%d");

													var color = d3.scaleQuantize()
														.domain([-0.03, 0.03])
														.range(["#f46d43", "#fdae61", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]);

													var svg = d3.select("#hm2").selectAll("svg")
														.data(d3.range(2018, 2019))
														.enter()
														.append("svg")
														.attr("width", width)
														.attr("height", height)
														.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													// svg.append("text")
													// 	.attr("transform", "translate(-6," + cellSize * 3.5 + ")rotate(-90)")
													// 	.style("text-anchor", "middle")
													// 	.attr("dy", -30)
													// 	.text(function (d) { return d; });

													var rect = svg.selectAll(".day")
														.data(function (d) { return d3.timeDays(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })
														.enter()
														.append("rect")
														.attr("class", "day")
														.style("fill", "#eee")
														.style("stoke", "#ccc")
														.attr("width", cellSize - 2)
														.attr("height", cellSize - 2)
														.attr("x", function (d) { return d3.timeWeek.count(d3.timeYear(d), d) * cellSize + 1; })
														.attr("y", function (d) { return d.getDay() * cellSize + 1; })
														.datum(format);
													svg.append("g")
														.attr("fill", "none")
														.attr("stroke", "#999")
														.attr("stroke-width", "0.5px")
														.selectAll("path")
														.data(function (d) { return d3.timeMonths(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })
														.enter().append("path")
														.attr("d", function (d) {
															var t1 = new Date(d.getFullYear(), d.getMonth() + 1, 0),
																d0 = d.getDay(), w0 = d3.timeWeek.count(d3.timeYear(d), d);
															d1 = t1.getDay(), w1 = d3.timeWeek.count(d3.timeYear(t1), t1);
															return "M" + (w0 + 1) * cellSize + "," + d0 * cellSize
																+ "H" + w0 * cellSize + "V" + 7 * cellSize
																+ "H" + w1 * cellSize + "V" + (d1 + 1) * cellSize
																+ "H" + (w1 + 1) * cellSize + "V" + 0
																+ "H" + (w0 + 1) * cellSize + "Z";
														});
													// var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
													// months.forEach(function (d, i) {
													// 	x = 4 + (3.5 * i);
													// 	x = x + "em";
													// 	svg.append("text")
													// 		.style("text-anchor", "end")
													// 		.attr("class", "month")
													// 		.attr("dy", "-.25em")
													// 		.attr("dx", x)
													// 		.text(d);
													// });
													// var days = ['', '', '', '', '', '', ''];
													// days.forEach(function (d, i) {
													// 	y = 0.8 + (1.7 * i);
													// 	y = y + "em";
													// 	svg.append("text")
													// 		.style("text-anchor", "end")
													// 		.attr("dy", y)
													// 		.attr("dx", "-1em")
													// 		.text(d);
													// });

													rect.append("title")
														.text(function (d) { return d; });

													var dataset = d3.csv("/demo/calendar.csv", function (data) {
														return data;
													});
													dataset.then(function (csv) {
														var data = d3.nest()
															.key(function (d) { return d.Date; })
															.rollup(function (d) { return (d[0].Close - d[0].Open) / d[0].Open; })
															.map(csv);
														rect.filter(function (d) {
															// d => yyyy-MM-dd
															return data.has(d);
														})
															.style("fill", function (d) {
																return color(data.get(d));
															})
															.select("title")
															.text(function (d) {
																return d + ": " + data.get(d);
															});
													});

													// var svgContainer = d3.select("#legend").append("svg")
													// 	.attr("width", 800)
													// 	.attr("height", 25);
													// svgContainer.append("text")
													// 	.attr("x", 0)
													// 	.attr("y", 25)
													// 	.text("Faible concentration d'accidents")

													// var rectangle = svgContainer.append("rect")
													// 	.attr("x", 160)
													// 	.attr("y", 10)
													// 	.attr("width", 20)
													// 	.attr("height", 20).attr("fill", "#006837");

													// svgContainer.append("rect")
													// 	.attr("x", 190)
													// 	.attr("y", 10)
													// 	.attr("width", 20)
													// 	.attr("height", 20).attr("fill", "#A6D96A");

													// svgContainer.append("rect")
													// 	.attr("x", 220)
													// 	.attr("y", 10)
													// 	.attr("width", 20)
													// 	.attr("height", 20).attr("fill", "#FEE08B"); svgContainer.append("rect")
													// 		.attr("x", 250)
													// 		.attr("y", 10)
													// 		.attr("width", 20)
													// 		.attr("height", 20).attr("fill", "#A50026");

													// svgContainer.append("text")
													// 	.attr("x", 280)
													// 	.attr("y", 25)
													// 	.text("Forte concentration d'accidents")
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/sebg/5098cc2b7ce04df27dcd5c384f5b791e */}}
													<h3 class="card-title">Extended stacked area chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="esac1" style="height: auto">
													</div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var svg = d3.select("#esac1").append("svg").attr("width", 712).attr("height", 450)
													var margin = { top: 9, right: 20, bottom: 30, left: 50 }
													var width = svg.attr("width") - margin.left - margin.right,
														height = svg.attr("height") - margin.top - margin.bottom;
													var parseDate = d3.timeParse("%Y-%m");

													var x = d3.scaleTime().range([0, width]),
														y = d3.scaleLinear().range([height, 0]),
														z = d3.scaleOrdinal(d3.schemeCategory10);
													// var line = d3.line()
													// 	.curve(d3.curveBasis)
													// 	.x(function (d) { return x(d.date); })
													// 	.y(function (d) { return y(d.price); });

													var stack = d3.stack().offset(d3.stackOffsetExpand);;

													var area = d3.area()
														.x(function (d, i) { return x(parseDate(d.data.Date)); })
														.y0(function (d) { return y(d[0]); })
														.y1(function (d) { return y(d[1]); });
													var g = svg.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var dataset = d3.tsv("/demo/marketshare.tsv", function(data) {
														return data;
													});
													dataset.then(function (data) {
														var keys = data.columns.slice(1);
														x.domain(d3.extent(data, function (d) {return parseDate(d.Date);}));
														z.domain(keys);
														stack.keys(keys);
														var layer = g.selectAll(".layer")
															.data(stack.keys(data.columns.slice(1))(data))
															.enter()
															.append("g")
															.attr("class", "layer");

														layer.append("path")
															.attr("class", "area")
															.style("fill", function (d) { return z(d.key); })
															.attr("d", area);

														layer.filter(function (d) { return d[d.length - 1][1] - d[d.length - 1][0] > 0.01; })
															.append("text")
															.attr("x", width - 6)
															.attr("y", function (d) { return y((d[d.length - 1][0] + d[d.length - 1][1]) / 2); })
															.attr("dy", ".35em")
															.style("fill", "#fff")
															.style("font", "13px sans-serif")
															.style("text-anchor", "end")
															.text(function (d) { return d.key; });

														g.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x));

														g.append("g")
															.attr("class", "axis axis--y")
															.call(d3.axisLeft(y).ticks(10, "%"));
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/Thanaporn-sk/d57656bb56a99e615c9d60540d2491f7 */}}
													<h3 class="card-title">Donut chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="dc1" style="height: auto;"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													function donutChart() {
														var width,
															height,
															margin = { top: 10, right: 10, bottom: 10, left: 10 },
															colour = d3.scaleOrdinal(d3.schemePaired), // colour scheme
															variable, // value in data that will dictate proportions on chart
															category, // compare data by
															padAngle, // effectively dictates the gap between slices
															floatFormat = d3.format('.4r'),
															cornerRadius, // sets how rounded the corners are on each slice
															percentFormat = d3.format(',.2%');

														function chart(selection)
														{
															selection.each(function (data) {
																// generate chart
																// Set up constructors for making donut. See https://github.com/d3/d3-shape/blob/master/README.md
																var radius = Math.min(width, height) / 2;

																// creates a new pie generator
																var pie = d3.pie()
																	.value(function (d) { return floatFormat(d[variable]); })
																	.sort(null);

																// contructs and arc generator. This will be used for the donut. The difference between outer and inner
																// radius will dictate the thickness of the donut
																var arc = d3.arc()
																	.outerRadius(radius * 0.8)
																	.innerRadius(radius * 0.6)
																	.cornerRadius(cornerRadius)
																	.padAngle(padAngle);

																// this arc is used for aligning the text labels
																var outerArc = d3.arc()
																	.outerRadius(radius * 0.9)
																	.innerRadius(radius * 0.9);

																// append the svg object to the selection
																var svg = selection.append('svg')
																	.attr('width', width + margin.left + margin.right)
																	.attr('height', height + margin.top + margin.bottom)
																	.style("-webkit-filter", "drop-shadow(0px 3px 3px rgba(0,0,0,.3))")
																	.style("filter", "drop-shadow(0px 3px 3px rgba(0,0,0,.25))")
																	.append('g')
																	.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

																// g elements to keep elements within svg modular
																svg.append('g').attr('class', 'slices');
																svg.append('g').attr('class', 'labelName');
																svg.append('g').attr('class', 'lines');

																// add and colour the donut slices
																var path = svg.select('.slices')
																	.datum(data).selectAll('path')
																	.data(pie)
																	.enter().append('path')
																	.attr('fill', function (d, i) {
																		return colour(d.data[category]);
																	})
																	.attr('d', arc);

																// add text labels
																var label = svg.select('.labelName').selectAll('text')
																	.data(pie)
																	.enter().append('text')
																	.style("font-style", "normal")
																	.attr("font-size", "12px")
																	.attr('dy', '.35em')
																	.html(function (d) {
																		// add "key: value" for given category. Number inside tspan is bolded in stylesheet.
																		return d.data[category] + ': <tspan>' + percentFormat(d.data[variable]) + '</tspan>';
																	})
																	.attr('transform', function (d) {

																		// effectively computes the centre of the slice.
																		// see https://github.com/d3/d3-shape/blob/master/README.md#arc_centroid
																		var pos = outerArc.centroid(d);

																		// changes the point to be on left or right depending on where label is.
																		pos[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
																		return 'translate(' + pos + ')';
																	})
																	.style('text-anchor', function (d) {
																		// if slice centre is on the left, anchor text to start, otherwise anchor to end
																		return (midAngle(d)) < Math.PI ? 'start' : 'end';
																	});

																// add lines connecting labels to slice. A polyline creates straight lines connecting several points
																var polyline = svg.select('.lines')
																	.selectAll('polyline')
																	.data(pie)
																	.enter().append('polyline')
																	.style("opacity", ".3")
																	.style("stroke", "#000")
																	.style("stroke-width", "2px")
																	.style("fill", "none")
																	.attr('points', function (d) {
																		// see label transform function for explanations of these three lines.
																		var pos = outerArc.centroid(d);
																		pos[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
																		return [arc.centroid(d), outerArc.centroid(d), pos]
																	});

																// add tooltip to mouse events on slices and labels
																d3.selectAll('.labelName text, .slices path').call(toolTip);

																// Functions

																// calculates the angle for the middle of a slice
																function midAngle(d)
																{
																	return d.startAngle + (d.endAngle - d.startAngle) / 2;
																}

																// function that creates and adds the tool tip to a selected element
																function toolTip(selection)
																{
																	// add tooltip (svg circle element) when mouse enters label or slice
																	selection.on('mouseenter', function (data) {
																		svg.append('text')
																			.attr('class', 'toolCircle')
																			.attr('dy', -15) // hard-coded. can adjust this to adjust text vertical alignment in tooltip
																			.html(toolTipHTML(data)) // add text to the circle.
																			.attr("font-size", "12px")
																			.style('text-anchor', 'middle'); // centres text in tooltip

																		svg.append('circle')
																			.attr('class', 'toolCircle')
																			.attr('r', radius * 0.55) // radius of tooltip circle
																			.style('fill', function (d, i) {
																				return colour(data.data[category]);
																			}) // colour based on category mouse is over
																			.style('fill-opacity', 0.35);
																	});

																	// remove the tooltip when mouse leaves the slice/label
																	selection.on('mouseout', function () {
																		d3.selectAll('.toolCircle').remove();
																	});
																}

																// function to create the HTML string for the tool tip. Loops through each key in data object
																// and returns the html string key: value
																function toolTipHTML(data)
																{
																	var tip = '',
																		i = 0;
																	for (var key in data.data) {
																		// if value is a number, format it as a percentage
																		var value = (!isNaN(parseFloat(data.data[key]))) ? percentFormat(data.data[key]) : data.data[key];
																		// leave off 'dy' attr for first tspan so the 'dy' attr on text element works. The 'dy' attr on
																		// tspan effectively imitates a line break.
																		if (i === 0) tip += '<tspan x="0">' + key + ': ' + value + '</tspan>';
																		else tip += '<tspan x="0" dy="1.2em">' + key + ': ' + value + '</tspan>';
																		i++;
																	}

																	return tip;
																}
															});
														}

														// getter and setter functions. See Mike Bostocks post "Towards Reusable Charts" for a tutorial on how this works.
														chart.width = function (value)
														{
															if (!arguments.length) return width;
															width = value;
															return chart;
														};

														chart.height = function (value)
														{
															if (!arguments.length) return height;
															height = value;
															return chart;
														};

														chart.margin = function (value)
														{
															if (!arguments.length) return margin;
															margin = value;
															return chart;
														};

														chart.radius = function (value)
														{
															if (!arguments.length) return radius;
															radius = value;
															return chart;
														};

														chart.padAngle = function (value)
														{
															if (!arguments.length) return padAngle;
															padAngle = value;
															return chart;
														};

														chart.cornerRadius = function (value)
														{
															if (!arguments.length) return cornerRadius;
															cornerRadius = value;
															return chart;
														};

														chart.colour = function (value)
														{
															if (!arguments.length) return colour;
															colour = value;
															return chart;
														};

														chart.variable = function (value)
														{
															if (!arguments.length) return variable;
															variable = value;
															return chart;
														};

														chart.category = function (value)
														{
															if (!arguments.length) return category;
															category = value;
															return chart;
														};

														return chart;
													}
													var donut = donutChart()
														.width(715)
														.height(300)
														.cornerRadius(3) // sets how rounded the corners are on each slice
														.padAngle(0.015) // effectively dictates the gap between slices
														.variable('Probability')
														.category('Species');

													d3.tsv('/demo/species.tsv', function (data) {
														return data;
													}).then(function (data) {
														d3.select('#dc1')
															.datum(data) // bind data to the div
															.call(donut); // draw chart in div
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/*
														http://blockbuilder.org/d3noob/ae9786c26d6a821eefeabe60dec350a9
														http://blockbuilder.org/jeremygnfsk/71f882b1ae4097b8bfe5c331d673b85a
													*/}}
													<h3 class="card-title">Multiple spline chart</h3>
												</div>
												<div class="card-body">
													<div id="mlc1" style="height: auto">
													</div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													// Set the dimensions of the canvas / graph
													var margin = { top: 30, right: 20, bottom: 30, left: 50 },
														width = 712 - margin.left - margin.right,
														height = 300 - margin.top - margin.bottom;
													var svg = d3.select("#mlc1")
														.append("svg")
														.attr("width", width + margin.left + margin.right)
														.attr("height", height + margin.top + margin.bottom)
														.append("g")
														.attr("transform",
															"translate(" + margin.left + "," + margin.top + ")");

													// Parse the date / time
													var parseDate = d3.timeParse("%b %Y");

													// Set the ranges
													var x = d3.scaleTime().range([0, width]);
													var y = d3.scaleLinear().range([height, 0]);

													// Define the line
													var line = d3.line()
														.x(function (d) { return x(d.date); })
														.y(function (d) { return y(d.price); });

													// Get the data
													var dataset = d3.tsv("/demo/stocks.tsv", function (data) {
														return data;
													});
													dataset.then(function (data) {
														return data.map(function (d) {
															d.date = parseDate(d.date);
															d.price = +d.price;
															return d;
														});
													}).then(function (data) {
														// Scale the range of the data
														x.domain(d3.extent(data, function (d) { return d.date; }));
														y.domain([0, d3.max(data, function (d) { return d.price; })]);

														// Nest the entries by symbol
														var nest = d3.nest()
															.key(function (d) { return d.symbol; })
															.entries(data);

														// set the colour scale
														var color = d3.scaleOrdinal(d3.schemeCategory10);
														// Loop through each symbol / key
														nest.map(function (d) {
															svg.append("path")
																.style("stroke-width", "2")
																.style("fill", "none")
																.style("stroke", function () { // Add the colours dynamically
																	return d.color = color(d.key);
																})
																.attr("d", line(d.values));
														});

														// Add the X Axis
														svg.append("g")
															.attr("class", "axis")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x))
															.style("fill", "none")
															.style("stoke", "grey")
															.style("stoke-width", "1")
															.style("shape-rendering", "crispEdges");

														// Add the Y Axis
														svg.append("g")
															.attr("class", "axis")
															.call(d3.axisLeft(y))
															.style("fill", "none")
															.style("stoke", "grey")
															.style("stoke-width", "1")
															.style("shape-rendering", "crispEdges");
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/curran/02163a13a40112e0ab6f14bbacc986f8 */}}
													<h3 class="card-title">Small multiple line chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="smlc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var parseDate = d3.timeParse("%b %Y");

													function timeSeriesChart()
													{
														var margin = { top: 10, right: 10, bottom: 10, left: 10 },
															width = 712,
															height = 64,
															xValue = function (d) { return d[0]; },
															yValue = function (d) { return d[1]; },
															xScale = d3.scaleTime(),
															yScale = d3.scaleLinear(),
															xAxis = d3.axisBottom().scale(xScale).tickSize(6, 0),
															area = d3.area().x(X).y1(Y),
															line = d3.line().x(X).y(Y),
															values = function (d) { return d; },
															title = null,
															titleX = -30,
															titleY = 25,
															xExtent = null;

														function chart(selection)
														{
															selection.each(function (d) {
																// Convert data to standard representation greedily;
																// this is needed for nondeterministic accessors.
																var data = values(d).map(function (d, i) {
																	return [xValue.call(data, d, i), yValue.call(data, d, i)];
																});

																// Update the x-scale.
																xScale
																	.domain(xExtent || d3.extent(data, function (d) { return d[0]; }))
																	.range([0, width - margin.left - margin.right]);

																// Update the y-scale.
																yScale
																	.domain([0, d3.max(data, function (d) { return d[1]; })])
																	.range([height - margin.top - margin.bottom, 0]);

																// Select the svg element, if it exists.
																var svg = d3.select(this).selectAll("svg").data([data]);
																var svgEnter = svg.enter().append("svg");

																// Otherwise, create the skeletal chart.
																var gEnter = svgEnter.append("g");
																gEnter.append("text").attr("class", "title").attr("font-size", "12px");
																gEnter.append("path").attr("class", "area").attr("fill", "#c6c6c6");
																gEnter.append("path").attr("class", "line").attr("stroke", "#707070");
																gEnter.append("g").attr("class", "x axis");

																// Update the outer dimensions.
																svg = svg.merge(svgEnter);
																svg.attr("width", width)
																	.attr("height", height);

																// Update the inner dimensions.
																var g = svg.select("g")
																	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

																// Update the area path.
																area.y0(yScale(0));
																g.select(".area")
																	.attr("d", area)
																	.attr("fill", "#e7e7e7");

																// Update the line path.
																g.select(".line")
																	.attr("d", line)
																	.attr("fill", "none")
																	.attr("stroke", "#666")
																	.attr("stroke-width", "1.5px");

																// Update the x-axis.
																g.select(".x.axis")
																	.attr("transform", "translate(0," + yScale.range()[0] + ")")
																	.call(xAxis);

																// Update the title.
																if (title) {
																	g.select(".title")
																		.attr("x", titleX)
																		.attr("y", titleY)
																		.attr("text-anchor", "end")
																		.text(title(d))
																		.attr("font-size", "12px");
																}
															});
														}

														// The x-accessor for the path generator; xScale  xValue.
														function X(d)
														{
															return xScale(d[0]);
														}

														// The x-accessor for the path generator; yScale  yValue.
														function Y(d)
														{
															return yScale(d[1]);
														}

														chart.margin = function (_)
														{
															if (!arguments.length) return margin;
															margin = _;
															return chart;
														};

														chart.width = function (_)
														{
															if (!arguments.length) return width;
															width = _;
															return chart;
														};

														chart.height = function (_)
														{
															if (!arguments.length) return height;
															height = _;
															return chart;
														};

														chart.x = function (_)
														{
															if (!arguments.length) return xValue;
															xValue = _;
															return chart;
														};

														chart.y = function (_)
														{
															if (!arguments.length) return yValue;
															yValue = _;
															return chart;
														};

														chart.values = function (_)
														{
															if (!arguments.length) return values;
															values = _;
															return chart;
														};

														chart.title = function (_)
														{
															if (!arguments.length) return title;
															title = _;
															return chart;
														};

														chart.titleX = function (_)
														{
															if (!arguments.length) return titleX;
															titleX = _;
															return chart;
														};

														chart.titleY = function (_)
														{
															if (!arguments.length) return titleY;
															titleY = _;
															return chart;
														};

														chart.xExtent = function (_)
														{
															if (!arguments.length) return xExtent;
															xExtent = _;
															return chart;
														};

														return chart;
													}
													var chart = timeSeriesChart()
														.x(function (d) { return parseDate(d.date); })
														.y(function (d) { return +d.price; })
														.width(712)
														.height(64)
														.values(function (d) { return d.values; })
														.title(function (d) { return d.key; })
														.margin({ top: 20, right: 20, bottom: 20, left: 100 });
													// Get the data
													var dataset = d3.tsv("/demo/stocks.tsv", function (data) {
														return data;
													});
													dataset.then(function (data) {
														// Scale the range of the data
														// x.domain(d3.extent(data, function (d) { return d.date; }));
														// y.domain([0, d3.max(data, function (d) { return d.price; })]);

														// Nest the entries by symbol
														var symbols = d3.nest()
															.key(function (d) { return d.symbol; })
															.entries(data);
														// Use a global extent (so GOOG's axis is aligned with the others).
														chart.xExtent(d3.extent(data, chart.x()));

														d3.select("#smlc1")
															.selectAll(".smlc1")
															.data(symbols)
															.enter()
															.append("div")
															.attr("class", "smlc1")
															.call(chart);
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/curran/02163a13a40112e0ab6f14bbacc986f8 */}}
													<h3 class="card-title">Small multiple line chart - 2</h3>
												</div>
												<div class="card-body">
													<div id="smlc2" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var margin = { top: 20, right: 30, bottom: 20, left: 50 },
														width = 712 - margin.left - margin.right,
														height = 450 - margin.top - margin.bottom,
														area = d3.area()
															.x(function (d) { return x(d.date); })
															.y0(function (d) { return y(0); })
															.y1(function (d) { return y(d.price); });;

													var svg = d3.select("#smlc2").append("svg")
														.attr("width", width + margin.left + margin.right)
														.attr("height", height + margin.top + margin.bottom)
														.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var parseDate = d3.timeParse("%b %Y");

													var x = d3.scaleTime().range([0, width]),
														y = d3.scaleLinear().range([height, 0]),
														c = d3.scaleOrdinal(d3.schemeCategory10);

													var line = d3.line()
														.curve(d3.curveBasis)
														.x(function (d) { return x(d.date); })
														.y(function (d) { return y(d.price); });

													var dataset = d3.tsv("/demo/stocks.tsv", function (data) {
														return data;
													});
													dataset.then(function (data) {
														// Scale the range of the data
														// x.domain(d3.extent(data, function (d) { return d.date; }));
														// y.domain([0, d3.max(data, function (d) { return d.price; })]);

														// Nest the entries by symbol
														var symbols = d3.nest()
															.key(function (d) { return d.symbol; })
															.entries(data);

														// Parse and caculate some values for each symbols
														symbols.forEach(function (s) {
															s.values.forEach(function (d) {
																d.date = parseDate(d.date);
																d.price = +d.price;
															});

															s.maxPrice = d3.max(s.values, function (d) { return d.price; });
															s.sumPrice = d3.sum(s.values, function (d) { return d.price; });
														});
														x.domain(d3.extent(data, function (d) { return d.date; }));
														y.domain([0, d3.max(symbols.map(function (d) { return d.maxPrice; }))])

														for (var i = 0; i < symbols.length; i++) {
															y.range([(i + 1) * height / symbols.length, i * height / symbols.length])
																.domain([0, symbols[i].maxPrice]);

															svg.append("path").datum(symbols[i])
																.attr("class", "line")
																.attr("d", function (d) { return line(d.values); })
																.attr("stroke", function (d) { return c(d.key); })
																.attr("stroke-width", "1.5px")
																.attr("fill", "none");

															svg.append("path").datum(symbols[i])
																.attr("class", "area")
																.attr("d", function (d) { return area(d.values); })
																.attr("fill", function (d) { return c(d.key); })
																.attr("opacity", "0.5");

															svg.append("g")
																.attr("class", "axis axis--y")
																.call(d3.axisLeft(y).ticks(5));
														}

														svg.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height + ")")
															.call(d3.axisBottom(x));


														var legend = svg.selectAll(".legend")
															.data(c.domain())
															.enter().append("g")
															.attr("class", "legend")
															.attr("transform", function (d, i) { return "translate(0," + i * 20 + ")"; });

														legend.append("rect")
															.attr("x", 30)
															.attr("width", 18)
															.attr("height", 18)
															.style("fill", c);

														legend.append("text")
															.attr("x", 50)
															.attr("y", 9)
															.attr("dy", ".35em")
															.style("text-anchor", "start")
															.text(function (d) { return d; });
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* https://bl.ocks.org/mbostock/e1192fe405703d8321a5187350910e08 */}}
													<h3 class="card-title">Local Variables</h3>
												</div>
												<div class="card-body">
													<div id="lv1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var margin = {top: 8, right: 10, bottom: 2, left: 10},
														width = 712 - margin.left - margin.right,
														height = 69 - margin.top - margin.bottom;
													var parseDate = d3.timeParse("%b %Y");
													var x = d3.scaleTime().range([0, width]);
													var y = d3.local();
													var area = d3.local();
													var line = d3.local();

													d3.tsv("/demo/stocks.tsv", function (data) { return data; })
													.then(function (data) {
														return data.map(function (d) {
															d.date = parseDate(d.date);
															d.price = +d.price;
															return d;
														});
													}).then(function (data) {
														var symbols = d3.nest()
															.key(function (d) { return d.symbol; })
															.entries(data);

														x.domain([
															d3.min(symbols, function (symbol) { return symbol.values[0].date; }),
															d3.max(symbols, function (symbol) { return symbol.values[symbol.values.length - 1].date; })
														]);

														var svg = d3.select("#lv1").selectAll("svg")
															.data(symbols)
															.enter().append("svg")
															.attr("width", width + margin.left + margin.right)
															.attr("height", height + margin.top + margin.bottom)
															.append("g")
															.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
															.each(function (d) {
																var ty = y.set(this, d3.scaleLinear()
																	.domain([0, d3.max(d.values, function (d) { return d.price; })])
																	.range([height, 0]));

																area.set(this, d3.area()
																	.x(function (d) { return x(d.date); })
																	.y0(height)
																	.y1(function (d) { return ty(d.price); }));

																line.set(this, d3.line()
																	.x(function (d) { return x(d.date); })
																	.y(function (d) { return ty(d.price); }));
															});

														svg.append("path")
															.attr("class", "area")
															.attr("d", function (d) { return area.get(this)(d.values); })
															.attr("fill", "#e7e7e7");

														svg.append("path")
															.attr("class", "line")
															.attr("d", function (d) { return line.get(this)(d.values); })
															.attr("fill", "none")
															.attr("stroke", "#666")
															.attr("stroke-width", "1.5px");

														svg.append("text")
															.attr("x", width - 6)
															.attr("y", height - 6)
															.text(function (d) { return d.key; })
															.attr("text-anchor", "end");
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/*
														http://blockbuilder.org/Thanaporn-sk/6e0f4bd2b2ecae24734b4cd845117224
														http://blockbuilder.org/chornbaker/98ade423c8e030ce3faea2fdced93e62
													*/}}
													<h3 class="card-title">Stacked to grouped chart - 1</h3>
												</div>
												<div class="card-body">
													<form>
														<label><input type="radio" name="s2g-mode" value="percent"> Percent</label>
														<label><input type="radio" name="s2g-mode" value="grouped"> Grouped</label>
														<label><input type="radio" name="s2g-mode" value="stacked"> Stacked</label>
													</form>
													<div id="sgc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var n = 4, // number of layers
														m = 48, // number of samples per layer
														stack = d3.stack(),
														data = d3.range(n).map(function () { return bumpLayer(m, .1); }),
														yOffset = {},
														yRecover = {},
														yRecoverDomain,
														isTransitioning = true,
														transitionDuration = 500;

													var formatPercent = d3.format(".0%");
													var formatNumber = d3.format(",");

													// transpose data
													data = data[0].map(function (col, i) {
														return data.map(function (row) {
															return row[i]
														})
													});

													var layers = stack.keys(d3.range(n))(data),
														yStackMax = d3.max(layers, function (layer) { return d3.max(layer, function (d) { return d[1]; }); }),
														yGroupMax = d3.max(layers, function (layer) { return d3.max(layer, function (d) { return d[1] - d[0]; }); });

													var margin = { top: 40, right: 10, bottom: 20, left: 40 },
														width = 712 - margin.left - margin.right,
														height = 320 - margin.top - margin.bottom;

													var x = d3.scaleBand()
														.domain(d3.range(m))
														.rangeRound([0, width])
														.padding(0.1)
														.align(0.1);

													var y = d3.scaleLinear()
														.domain([0, yStackMax])
														.rangeRound([height, 0]);

													var color = d3.scaleLinear()
														.domain([0, n - 1])
														.range(["#aad", "#556"]);

													var xAxis = d3.axisBottom()
														.scale(x)
														.tickSize(0)
														.tickPadding(6);

													var yAxis = d3.axisLeft()
														.scale(y)
														.tickSize(2)
														.tickPadding(6);

													var svg = d3.select("#sgc1").append("svg")
														.attr("width", width + margin.left + margin.right)
														.attr("height", height + margin.top + margin.bottom)
														.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var layer = svg.selectAll(".layer")
														.data(layers)
														.enter().append("g")
														.attr("class", "layer")
														.attr("id", function (d) { return d.key; })
														.style("fill", function (d, i) { return color(i); })

													var rect = layer.selectAll("rect")
														.data(function (d) { return d; })
														.enter().append("rect")
														.attr("x", function (d, i) { return x(i); })
														.attr("y", height)
														.attr("width", x.bandwidth())
														.attr("height", 0)
														.on("mouseenter", highlightLayer)
														.on("mouseout", restoreLayer);

													rect.transition()
														.delay(function (d, i) { return i * 10; })
														.attr("y", function (d) { return y(d[1]); })
														.attr("height", function (d) { return y(d[0]) - y(d[1]); });

													svg.append("g")
														.attr("class", "x axis")
														.attr("transform", "translate(0," + height + ")")
														.call(xAxis);

													svg.append("g")
														.attr("class", "y axis")
														.attr("transform", "translate(" + 0 + ",0)")
														.style("font-size", "10px")
														.call(yAxis);

													d3.selectAll("input[name=s2g-mode]").on("change", function () {
														isTransitioning = true;
														setTimeout(function () { isTransitioning = false; }, transitionDuration * 3.5);
														switch(this.value) {
															case "grouped":
																transitionGrouped();
																break;
															case "stacked":
																transitionStacked();
																break;
															case "percent":
																transitionPercent();
																break;
														}
													});

													function transitionGrouped()
													{
														y.domain([0, yGroupMax]);

														rect.transition()
															.duration(transitionDuration)
															.delay(function (d, i) { return i * 10; })
															.attr("x", function (d, i, j) { return x(i) + x.bandwidth() / n * parseInt(this.parentNode.id); })
															.attr("width", x.bandwidth() / n)
															.transition()
															.attr("y", function (d) { return height - (y(d[0]) - y(d[1])); })
															.attr("height", function (d) { return y(d[0]) - y(d[1]); })
															.on("end", setYRecover);

														yAxis.tickFormat(formatNumber)
														svg.selectAll(".y.axis").transition()
															.delay(transitionDuration)
															.duration(transitionDuration)
															.call(yAxis)
													}

													function transitionStacked()
													{
														y.domain([0, yStackMax]);

														rect.transition()
															.duration(transitionDuration)
															.delay(function (d, i) { return i * 10; })
															.attr("y", function (d) { return y(d[1]); })
															.attr("height", function (d) { return y(d[0]) - y(d[1]); })
															.transition()
															.attr("x", function (d, i) { return x(i); })
															.attr("width", x.bandwidth())
															.on("end", setYRecover);

														yAxis.tickFormat(formatNumber)
														svg.selectAll(".y.axis").transition()
															.delay(transitionDuration)
															.duration(transitionDuration)
															.call(yAxis);
													}

													function transitionPercent()
													{
														y.domain([0, 1]);

														rect.transition()
															.duration(transitionDuration)
															.delay(function (d, i) { return i * 10; })
															.attr("y", function (d) {
																var total = d3.sum(d3.values(d.data));
																return y(d[1] / total);
															})
															.attr("height", function (d) {
																var total = d3.sum(d3.values(d.data));
																return y(d[0] / total) - y(d[1] / total);
															})
															.transition()
															.attr("x", function (d, i) { return x(i); })
															.attr("width", x.bandwidth())
															.on("end", setYRecover);

														yAxis.tickFormat(formatPercent)
														svg.selectAll(".y.axis").transition()
															.delay(transitionDuration)
															.duration(transitionDuration)
															.call(yAxis);
													}

													function setYRecover(d, i)
													{
														j = parseInt(d3.select(this.parentNode).attr("id"))
														if (typeof (yRecover[i]) === 'undefined') { yRecover[i] = {} };
														yRecover[i][j] = parseFloat(d3.select(this).attr("y"));
														yRecoverDomain = y.domain();
													}

													function highlightLayer(d, i)
													{
														if (isTransitioning == false) {
															// Highlight layer
															var j = parseInt(d3.select(this.parentNode).attr("id"))
															layer.transition()
																.style("opacity", function () {
																	return parseInt(this.id) == j ? 1 : 0.2;
																});

															// Align bottom of selected layer
															var layerRects = d3.selectAll(this.parentNode.childNodes).selectAll(".rect")._parents;
															var baseline = yRecover[i][j] + parseFloat(d3.select(this).attr("height"));
															layerRects.forEach(function (d, i) {
																yOffset[i] = baseline - (parseFloat(d3.select(d).attr("y")) + parseFloat(d3.select(d).attr("height")));
															})
															rect.transition()
																.attr("y", function (d, i) {
																	return parseFloat(d3.select(this).attr("y")) + yOffset[i];
																});

															// Match y axis to bottom of layer
															y.domain([y.domain()[0] - y.invert(baseline), y.domain()[1] - y.invert(baseline)])
															svg.selectAll(".y.axis").transition()
																.call(yAxis);
														}
													}

													function restoreLayer(d, i)
													{
														if (isTransitioning == false) {
															// Restore layer opacity
															layer.transition()
																.style("opacity", 1)

															// Restore bar Y values
															rect.transition()
																.attr("y", function (d, i) {
																	j = parseInt(d3.select(this.parentNode).attr("id"))
																	return yRecover[i][j];
																})

															// Restore y axis
															y.domain(yRecoverDomain)
															svg.selectAll(".y.axis").transition()
																.call(yAxis);
														}
													}

													// Inspired by Lee Byron's test data generator.
													function bumpLayer(n, o)
													{
														function bump(a)
														{
															var x = 1 / (.1 + Math.random()),
																y = 2 * Math.random() - .5,
																z = 10 / (.1 + Math.random());
															for (var i = 0; i < n; i++) {
																var w = (i / n - y) * z;
																a[i] += x * Math.exp(-w * w);
															}
														}

														var a = [], i;
														for (i = 0; i < n; ++i) a[i] = o + o * Math.random();
														for (i = 0; i < 5; ++i) bump(a);

														return a.map(function (d, i) { return Math.max(0, d); });
													}
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/*
														http://blockbuilder.org/gcalmettes/0ab8e8e1c64fa07e5fe62ae606624cb6
														http://blockbuilder.org/tlfrd/dfee3b6061e50ad73d9df7a7a73b68e9
													*/}}
													<h3 class="card-title">Radar chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="rc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var RadarChart = {
														draw: function (id, d, options) {
															var cfg = {
																radius: 5,
																w: 600,
																h: 600,
																factor: 1,
																factorLegend: .85,
																levels: 3,
																maxValue: 0,
																radians: 2 * Math.PI,
																opacityArea: 0.5,
																ToRight: 5,
																ExtraWidthX: 100,
																ExtraWidthY: 100,
																color: d3.scaleOrdinal().range(["#6F257F", "#CA0D59"])
															};
															var margin = { top: 40, right: 40, bottom: 40, left: 40 };
															if ('undefined' !== typeof options) {
																for (var i in options) {
																	if ('undefined' !== typeof options[i]) {
																		cfg[i] = options[i];
																	}
																}
															}
															var min = Math.min(cfg.w, cfg.h) - margin.left - margin.right;
															var translateX = (cfg.w - min) / 2;
															var translateY = (cfg.h - min) / 2;
															cfg.maxValue = 100;

															var allAxis = (d[0].map(function (i, j) { return i.area }));
															var total = allAxis.length;
															var radius = cfg.factor * min / 2 ;
															var Format = d3.format('%');
															d3.select(id).select("svg").remove();

															var g = d3.select(id)
																.append("svg")
																.attr("width", cfg.w)
																.attr("height", cfg.h)
																.append("g")
																.attr("transform", "translate(" + translateX + "," + translateY + ")");

															var tooltip;

															//Circular segments
															for (var j = 0; j < cfg.levels; j++) {
																var levelFactor = cfg.factor * radius * ((j + 1) / cfg.levels);
																g.selectAll(".levels")
																	.data(allAxis)
																	.enter()
																	.append("svg:line")
																	.attr("x1", function (d, i) { return levelFactor * (1 - cfg.factor * Math.sin(i * cfg.radians / total)); })
																	.attr("y1", function (d, i) { return levelFactor * (1 - cfg.factor * Math.cos(i * cfg.radians / total)); })
																	.attr("x2", function (d, i) { return levelFactor * (1 - cfg.factor * Math.sin((i + 1) * cfg.radians / total)); })
																	.attr("y2", function (d, i) { return levelFactor * (1 - cfg.factor * Math.cos((i + 1) * cfg.radians / total)); })
																	.attr("class", "line")
																	.style("stroke", "grey")
																	.style("stroke-opacity", "0.75")
																	.style("stroke-width", "0.3px")
																	.attr("transform", "translate(" + (min / 2 - levelFactor) + ", " + (min / 2 - levelFactor) + ")");
															}

															//Text indicating at what % each level is
															for (var j = 0; j < cfg.levels; j++) {
																var levelFactor = cfg.factor * radius * ((j + 1) / cfg.levels);
																g.selectAll(".levels")
																	.data([1]) //dummy data
																	.enter()
																	.append("svg:text")
																	.attr("x", function (d) { return levelFactor * (1 - cfg.factor * Math.sin(0)); })
																	.attr("y", function (d) { return levelFactor * (1 - cfg.factor * Math.cos(0)); })
																	.attr("class", "legend")
																	.style("font-family", "sans-serif")
																	.style("font-size", "10px")
																	.attr("transform", "translate(" + (min / 2 - levelFactor + cfg.ToRight) + ", " + (min / 2 - levelFactor) + ")")
																	.attr("fill", "#737373")
																	.text((j + 1) * 100 / cfg.levels);
															}

															series = 0;

															var axis = g.selectAll(".axis")
																.data(allAxis)
																.enter()
																.append("g")
																.attr("class", "axis");

															axis.append("line")
																.attr("x1", min / 2)
																.attr("y1", min / 2)
																.attr("x2", function (d, i) { return min / 2 * (1 - cfg.factor * Math.sin(i * cfg.radians / total)); })
																.attr("y2", function (d, i) { return min / 2 * (1 - cfg.factor * Math.cos(i * cfg.radians / total)); })
																.attr("class", "line")
																.style("stroke", "grey")
																.style("stroke-width", "1px");

															axis.append("text")
																.attr("class", "legend")
																.text(function (d) { return d })
																.style("font-family", "sans-serif")
																.style("font-size", "11px")
																.attr("text-anchor", "middle")
																.attr("dy", "1.5em")
																.attr("transform", function (d, i) { return "translate(0, -10)" })
																.attr("x", function (d, i) { return min / 2 * (1 - cfg.factorLegend * Math.sin(i * cfg.radians / total)) - 60 * Math.sin(i * cfg.radians / total); })
																.attr("y", function (d, i) { return min / 2 * (1 - Math.cos(i * cfg.radians / total)) - 20 * Math.cos(i * cfg.radians / total); });


															d.forEach(function (y, x) {
																dataValues = [];
																g.selectAll(".nodes")
																	.data(y, function (j, i) {
																		dataValues.push([
																			min / 2 * (1 - (parseFloat(Math.max(j.value, 0)) / cfg.maxValue) * cfg.factor * Math.sin(i * cfg.radians / total)),
																			min / 2 * (1 - (parseFloat(Math.max(j.value, 0)) / cfg.maxValue) * cfg.factor * Math.cos(i * cfg.radians / total))
																		]);
																	});
																dataValues.push(dataValues[0]);
																g.selectAll(".area")
																	.data([dataValues])
																	.enter()
																	.append("polygon")
																	.attr("class", "radar-chart-serie" + series)
																	.style("stroke-width", "2px")
																	.style("stroke", cfg.color(series))
																	.attr("points", function (d) {
																		var str = "";
																		for (var pti = 0; pti < d.length; pti++) {
																			str = str + d[pti][0] + "," + d[pti][1] + " ";
																		}
																		return str;
																	})
																	.style("fill", function (j, i) { return cfg.color(series) })
																	.style("fill-opacity", cfg.opacityArea)
																	.on('mouseover', function (d) {
																		z = "polygon." + d3.select(this).attr("class");
																		g.selectAll("polygon")
																			.transition(200)
																			.style("fill-opacity", 0.1);
																		g.selectAll(z)
																			.transition(200)
																			.style("fill-opacity", .7);
																	})
																	.on('mouseout', function () {
																		g.selectAll("polygon")
																			.transition(200)
																			.style("fill-opacity", cfg.opacityArea);
																	});
																series++;
															});
															series = 0;


															var tooltip = d3.select("#rc1").append("div").attr("class", "toolTip");
															d.forEach(function (y, x) {
																g.selectAll(".nodes")
																	.data(y).enter()
																	.append("svg:circle")
																	.attr("class", "radar-chart-serie" + series)
																	.attr('r', cfg.radius)
																	.attr("alt", function (j) { return Math.max(j.value, 0) })
																	.attr("cx", function (j, i) {
																		dataValues.push([
																			min / 2 * (1 - (parseFloat(Math.max(j.value, 0)) / cfg.maxValue) * cfg.factor * Math.sin(i * cfg.radians / total)),
																			min / 2 * (1 - (parseFloat(Math.max(j.value, 0)) / cfg.maxValue) * cfg.factor * Math.cos(i * cfg.radians / total))
																		]);
																		return min / 2 * (1 - (Math.max(j.value, 0) / cfg.maxValue) * cfg.factor * Math.sin(i * cfg.radians / total));
																	})
																	.attr("cy", function (j, i) {
																		return min / 2 * (1 - (Math.max(j.value, 0) / cfg.maxValue) * cfg.factor * Math.cos(i * cfg.radians / total));
																	})
																	.attr("data-id", function (j) { return j.area })
																	.style("fill", "#fff")
																	.style("stroke-width", "2px")
																	.style("stroke", cfg.color(series)).style("fill-opacity", .9)
																	.on('mouseover', function (d) {
																		console.log(d.area)
																		tooltip
																			.style("left", d3.event.pageX - 40 + "px")
																			.style("top", d3.event.pageY - 80 + "px")
																			.style("display", "inline-block")
																			.html((d.area) + "<br><span>" + (d.value) + "</span>");
																	})
																	.on("mouseout", function (d) { tooltip.style("display", "none"); });

																series++;
															});
														}
													};
													//Call function to draw the Radar chart
													var width = 712,
														height = 300;

													// Config for the Radar chart
													var config = {
														w: width,
														h: height,
														maxValue: 100,
														levels: 5,
														ExtraWidthX: 300
													}
													
													//Call function to draw the Radar chart
													var data = [
														[
															{"area": "Central ","value": 80},
															{"area": "Kirkdale","value": 40},
															{"area": "Kensington ","value": 40},
															{"area": "Everton ","value": 90},
															{"area": "Picton ","value": 60},
															{"area": "Riverside ","value": 80}
														]
													];
													RadarChart.draw("#rc1", data, config);
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/*
														http://blockbuilder.org/gcalmettes/0ab8e8e1c64fa07e5fe62ae606624cb6
														http://blockbuilder.org/tlfrd/dfee3b6061e50ad73d9df7a7a73b68e9
														http://bl.ocks.org/santiagogaray/d613033cf9749ad97eab0b293b0127d2/6dbd1b85ed0ddbea6792fe66b9425675a2a47273
														https://www.wired.com/2013/10/tweet-bots/
													*/}}
													<h3 class="card-title">Joyplot chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="jc1" style="height: auto; background: DarkSlateBlue;font-family: 'Share Tech Mono', monospace;color: white"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													//returns the length of the opposite side to the angle, using the adjacent side's length
													function oppositeTan(angle, adjacent) {
														return Math.tan(angle) * adjacent;
													};

													//returns the length of the adjacent side to the angle, using the hypotenuse's length
													function adjacentCos(angle, hypotenuse) {
														return Math.cos(angle) * hypotenuse;
													}

													//returns the length of the opposite side to the angle, using the adjacent's length
													function oppositeTan(angle, adjacent) {
														return Math.tan(angle) * adjacent;
													}

													//returns the length of the adjacent side to the angle, using the opposite's length
													function adjacentTan(angle, opposite) {
														return opposite / Math.tan(angle);
													}

													//returns the length of the opposite side to the angle, using the hypotenuse's length
													function oppositeSin(angle, hypotenuse) {
														return Math.sin(angle) * hypotenuse;
													}

													//returns the angle using the opposite and adjacent
													function angleTan(opposite, adjacent) {
														return Math.atan(opposite / adjacent);
													}

													//returns the length of the unknown side of a triangle, using the other two sides' lengths
													function triangleSide(sideA, sideB) {
														var hypothenuse, shorterSide;
														if (sideA > sideB) {
															hypothenuse = sideA;
															shorterSide = sideB;
														} else {
															hypothenuse = sideB;
															shorterSide = sideA;
														};
														return Math.sqrt(Math.pow(hypothenuse, 2) - Math.pow(shorterSide, 2))
													};

													//returns the length of the hypotenuse, using the other two sides' lengths
													function triangleHypotenuse(sideA, sideB) {
														return Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2))
													};

													var noOfCharts;
													var dataLength;
													var xTickValues = []

													var colour = d3.scaleSequential(d3.interpolatePlasma)
														.domain([100, 0])

													var formatTime = d3.timeFormat('%I %p');

													const gradientColours = [
														{ "offset": 0 },
														{ "offset": 21 },
														{ "offset": 60 },
														{ "offset": 100 }
													];

													const xDiagonal = 263;
													const zDiagonal = 413;
													const yHeight = 40;

													const xAngleDegrees = 25;
													const xzAngleDegrees = 95 + xAngleDegrees;
													const zAngleDegrees = 180 - xzAngleDegrees - xAngleDegrees;

													const xzAngle = xzAngleDegrees * (Math.PI / 180);
													const xAngle = xAngleDegrees * (Math.PI / 180); //between xDiagonal and horizontal
													const zAngle = zAngleDegrees * (Math.PI / 180);

													var xWidth = adjacentCos(xAngle, xDiagonal);
													var zWidth = adjacentCos(zAngle, zDiagonal);

													var xHeight = triangleSide(xWidth, xDiagonal);
													var zHeight = triangleSide(zWidth, zDiagonal);

													const margin = { "top": 20, "right": 20, "bottom": 50, "left": 100 };
													const containerHeight = xHeight + zHeight + yHeight;
													const containerWidth = xWidth + zWidth;

													var xScale = d3.scaleTime()
														.range([0, xWidth]);

													var yScale = d3.scaleLinear()
														.range([yHeight, 0]);

													var activityScale = d3.scaleBand()
														.range([0, zWidth]);

													var zScale = d3.scaleLinear()
														.domain([0, (noOfCharts - 1)])
														.range([0, zWidth])

													var area = d3.area()
														.x(function (d, i) {
															return xScale(d.time);
														})
														.y0(function (d, i) {
															return yArea(0, i);
														})
														.y1(function (d, i) {
															return yArea(d.value, i);
														});

													var svg = d3.select("#jc1")
														.append("svg")
														.attr("width", containerWidth + margin.left + margin.right)
														.attr("height", containerHeight + margin.top + margin.bottom);

													var defs = svg.append("defs");

													var gradient = defs.append("linearGradient")
														.attr("id", "gradient")
														.attr("x1", 0)
														.attr("y1", 0)
														.attr("x2", 0)
														.attr("y2", yHeight)
														.attr("gradientUnits", "userSpaceOnUse")
														.attr("gradientTransform", "rotate(-" + xAngleDegrees + ",0,0)")

													gradient.selectAll("stop")
														.data(gradientColours)
														.enter()
														.append("stop")
														.attr("offset", function (d) { return d.offset + "%"; })
														.attr("stop-color", function (d) { return colour(d.offset); });

													var axes = svg.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
														.attr("class", "axes")

													var charts = svg.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
														.attr("class", "charts");

													var dataset = d3.tsv('/demo/joyplot.tsv', function (data) {
														return data;
													});
													dataset.then(function (data) {
														var c = data.map(function (d) {
															return {
																activity: d.activity,
																time: parseTime(d.time),
																value: +d.p_smooth
															};
														});
														return c;
													})
													.then(function (dataFlat) {
														// Sort by time
														dataFlat.sort(function (a, b) { return a.time - b.time; });

														var data = d3.nest()
															.key(function (d) { return d.activity; })
															.entries(dataFlat);

														// Sort activities by peak activity time
														function peakTime(d) {
															var i = d3.scan(d.values, function (a, b) { return b.value - a.value; });
															return d.values[i].time;
														};
														data.sort(function (a, b) { return peakTime(b) - peakTime(a); });

														noOfCharts = data.length;
														dataLength = data[0].values.length;
														xScale.domain(d3.extent(dataFlat, function (d) { return d.time; }));

														activityScale.domain(data.map(function (d) { return d.key; }));

														yScale.domain(d3.extent(dataFlat, function (d) { return d.value }));

														xTickValues = [0, 0.25, 0.5, 0.75, 1]
														axes.call(drawXAxis);
														data.map(function (d, i) {
															var series = i;
															var activity = d.key;
															var chartData = d.values;
															var g = charts.append("g")
																.attr("transform", "translate(" + areaOffsetX(series) + "," + areaOffsetY(series) + ")");

															g.append("text")
																.attr("class", "series-label")
																.text(activity)
																.attr("x", -8)
																.attr("y", yHeight + 8)
																.style("fill", "#fff")
																.style("font-size", "11px")
																.style("text-anchor", "end")

															var areaChart = g.append("path")
																.datum(chartData)
																.style("fill", "url(#gradient"/* + series + ")"*/)
																.attr("stroke", "DarkSlateBlue")
																.attr("stroke-linejoin", "round")
																.attr("stroke-linecap", "round")
																.attr("stroke-width", 1.5)
																.style("opacity", 0.8)
																.attr("d", area)
																.on("mouseover", function (d) {
																	d3.selectAll("path, .series-label").style("opacity", 0.1)
																	d3.select(this).style("opacity", 1)
																	d3.select(this.parentNode).select(".series-label").style("opacity", 1)
																})
																.on("mouseout", function (d) {
																	d3.selectAll("path").style("opacity", 0.8)
																	d3.selectAll(".series-label").style("opacity", 1)
																})
														})
													})

													function parseTime(offset) {
														var date = new Date(2017, 0, 1); // chose an arbitrary day
														return d3.timeMinute.offset(date, offset);
													}

													function areaOffsetX(i) {
														return i * (zWidth / (noOfCharts - 1))
													};

													function areaOffsetY(i) {
														var defaultY = containerHeight - zHeight - yHeight;
														var offset = i * (zHeight / (noOfCharts - 1));
														return defaultY + offset;
													};

													function yArea(d, i) {
														var n = xHeight * (i / dataLength);
														return yScale(d) - n;
													};

													function xCoord(x, y, z) {
														var x1 = xScale(x);
														var z1 = zScale(z);
														return seriesWidth + xScale(x) - zScale(z)
													};

													function yCoord(x, y, z) {
														var x1 = xHeight * (x / dataLength);
														var y1 = chartHeight - yScale(y);
														var z1 = zHeight * (z / noOfCharts);
														return height - (y1 + x1 + z1)
													};

													function drawXAxis(sel) {
														var xAxis = sel.append("g")
															.attr("id", "x-axis")
															.attr("transform", "translate(" + areaOffsetX(0) + "," + areaOffsetY(0) + ")");

														var xTicks = xAxis.selectAll(".ticks")
															.data(xTickValues)
															.enter()
															.append("g")
															.attr("class", "tick")
															.attr("transform", function (d) {
																var x = xWidth * (d);
																var y = yArea(0, (dataLength * (d)));
																return "translate(" + x + "," + y + ")"
															});

														var tickLength = zDiagonal + 25;
														var tickText = tickLength + 5;

														xTicks.append("line")
															.attr("x1", 0)
															.attr("y1", 0)
															.attr("x2", adjacentCos(zAngle, tickLength))
															.attr("y2", oppositeSin(zAngle, tickLength))
															.style("stroke", "lightgrey")
															.style("stroke-dasharray", "2,2");

														xTicks.append("text")
															.attr("class", "axis-label")
															.style("fill", "#fff")
															.text(function (d) { return formatTime(xScale.invert(xWidth * (d))); })
															.style("font-size", "11px")
															.attr("x", adjacentCos(zAngle, tickText))
															.attr("y", oppositeSin(zAngle, tickText));
													};
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/*
													http://blockbuilder.org/gcalmettes/0ab8e8e1c64fa07e5fe62ae606624cb6
													http://blockbuilder.org/tlfrd/dfee3b6061e50ad73d9df7a7a73b68e9
													http://bl.ocks.org/santiagogaray/d613033cf9749ad97eab0b293b0127d2/6dbd1b85ed0ddbea6792fe66b9425675a2a47273
													*/}}
													<h3 class="card-title">Joyplot chart - 2</h3>
												</div>
												<div class="card-body">
													<div id="jc2" style="height: auto; background: DarkSlateBlue;font-family: 'Share Tech Mono', monospace;color: white"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													//returns the length of the opposite side to the angle, using the adjacent side's length
													function oppositeTan(angle, adjacent) {
														return Math.tan(angle) * adjacent;
													};

													//returns the length of the adjacent side to the angle, using the hypotenuse's length
													function adjacentCos(angle, hypotenuse) {
														return Math.cos(angle) * hypotenuse;
													}

													//returns the length of the opposite side to the angle, using the adjacent's length
													function oppositeTan(angle, adjacent) {
														return Math.tan(angle) * adjacent;
													}

													//returns the length of the adjacent side to the angle, using the opposite's length
													function adjacentTan(angle, opposite) {
														return opposite / Math.tan(angle);
													}

													//returns the length of the opposite side to the angle, using the hypotenuse's length
													function oppositeSin(angle, hypotenuse) {
														return Math.sin(angle) * hypotenuse;
													}

													//returns the angle using the opposite and adjacent
													function angleTan(opposite, adjacent) {
														return Math.atan(opposite / adjacent);
													}

													//returns the length of the unknown side of a triangle, using the other two sides' lengths
													function triangleSide(sideA, sideB) {
														var hypothenuse, shorterSide;
														if (sideA > sideB) {
															hypothenuse = sideA;
															shorterSide = sideB;
														} else {
															hypothenuse = sideB;
															shorterSide = sideA;
														};
														return Math.sqrt(Math.pow(hypothenuse, 2) - Math.pow(shorterSide, 2))
													};

													//returns the length of the hypotenuse, using the other two sides' lengths
													function triangleHypotenuse(sideA, sideB) {
														return Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2))
													};

													const data = [0, 4, 1, 4, 6, 3, 8, 11, 2, 3, 3, 1, 8];
													const noOfCharts = 12;
													const dataLength = data.length;

													const domain = [0, d3.max(data)];

													var colour = d3.scaleSequential(d3.interpolatePlasma)
														.domain([100, 0])

													var xTickValues = [];
													for (t = 0; t < dataLength; t++) {
														xTickValues[t] = t;
													};

													const gradientColours = [
														{ "offset": 0 },
														{ "offset": 21 },
														{ "offset": 60 },
														{ "offset": 100 }
													];

													const xDiagonal = 360;
													const zDiagonal = 320;
													const yHeight = 80;

													const xAngleDegrees = 30;
													const xzAngleDegrees = 90 + xAngleDegrees;
													const zAngleDegrees = 180 - xzAngleDegrees - xAngleDegrees;

													const xzAngle = xzAngleDegrees * (Math.PI / 180);
													const xAngle = xAngleDegrees * (Math.PI / 180); //between xDiagonal and horizontal
													const zAngle = zAngleDegrees * (Math.PI / 180);

													var xWidth = adjacentCos(xAngle, xDiagonal);
													var zWidth = adjacentCos(zAngle, zDiagonal);

													var xHeight = triangleSide(xWidth, xDiagonal);
													var zHeight = triangleSide(zWidth, zDiagonal);

													const margin = { "top": 50, "right": 50, "bottom": 50, "left": 50 };
													const containerHeight = xHeight + zHeight + yHeight;
													const containerWidth = xWidth + zWidth;

													var xScale = d3.scaleLinear()
														.domain([0, (dataLength - 1)])
														.range([0, xWidth]);

													var yScale = d3.scaleLinear()
														.domain([0, d3.max(data)])
														.range([yHeight, 0]);

													var zScale = d3.scaleLinear()
														.domain([0, (noOfCharts - 1)])
														.range([0, zWidth])

													var area = d3.area()
														.x(function (d, i) {
															return xScale(i);
														})
														.y0(function (d, i) {
															return yArea(0, i);
														})
														.y1(function (d, i) {
															return yArea(d, i);
														});

													var svg = d3.select("#jc2")
														.append("svg")
														.attr("width", containerWidth + margin.left + margin.right)
														.attr("height", containerHeight + margin.top + margin.bottom);

													var defs = svg.append("defs");

													var axes = svg.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
														.attr("class", "axes")
														.call(drawXAxis);

													var charts = svg.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
														.attr("class", "charts");

													for (var series = 0; series < noOfCharts; series++) {
														var chartData = [];
														data.forEach(function (d, i) {
															let change = Math.ceil(Math.random() * 3);
															chartData[i] = data[i] + change;
														});

														var g = charts.append("g")
															.attr("transform", "translate(" + areaOffsetX(series) + "," + areaOffsetY(series) + ")");

														g.append("text")
															.attr("class", "axis-label")
															.text(series)
															.attr("x", -8)
															.attr("y", yHeight + 8)
															.style("fill", "#fff")
															.style("text-anchor", "end")

														var areaChart = g.append("path")
															.datum(chartData)
															.style("fill", "url(#gradient" + series + ")")
															.attr("stroke", "DarkSlateBlue")
															.attr("stroke-linejoin", "round")
															.attr("stroke-linecap", "round")
															.attr("stroke-width", 1.5)
															.style("fill-opacity", 0.9)
															.attr("d", area);

														var gradient = defs.append("linearGradient")
															.attr("id", "gradient" + series)
															.attr("x1", 0)
															.attr("y1", 0)
															.attr("x2", 0)
															.attr("y2", yHeight)
															.attr("gradientUnits", "userSpaceOnUse")
															.attr("gradientTransform", "rotate(-" + xAngleDegrees + ",0,0)")

														gradient.selectAll("stop")
															.data(gradientColours)
															.enter()
															.append("stop")
															.attr("offset", function (d) { return d.offset + "%"; })
															.attr("stop-color", function (d) { return colour(d.offset); });

													}; //end of for loop

													function areaOffsetX(i) {
														return i * (zWidth / (noOfCharts - 1))
													};

													function areaOffsetY(i) {
														var defaultY = containerHeight - zHeight - yHeight;
														var offset = i * (zHeight / (noOfCharts - 1));
														return defaultY + offset;
													};

													function yArea(d, i) {
														var n = xHeight * (i / dataLength)
														return yScale(d) - n;
													};

													function xCoord(x, y, z) {
														var x1 = xScale(x);
														var z1 = zScale(z);
														return seriesWidth + xScale(x) - zScale(z)
													};

													function yCoord(x, y, z) {
														var x1 = xHeight * (x / dataLength);
														var y1 = chartHeight - yScale(y);
														var z1 = zHeight * (z / noOfCharts);
														return height - (y1 + x1 + z1)
													};

													function drawXAxis(sel) {
														var xAxis = sel.append("g")
															.attr("id", "x-axis")
															.attr("transform", "translate(" + areaOffsetX(0) + "," + areaOffsetY(0) + ")");

														var xTicks = xAxis.selectAll(".ticks")
															.data(xTickValues)
															.enter()
															.append("g")
															.attr("class", "tick")
															.attr("transform", function (d) {
																let x = xScale(d);
																let y = yArea(0, d);
																return "translate(" + x + "," + y + ")"
															});

														var tickLength = zDiagonal + 25;
														var tickText = tickLength + 5;

														xTicks.append("line")
															.attr("x1", 0)
															.attr("y1", 0)
															.attr("x2", adjacentCos(zAngle, tickLength))
															.attr("y2", oppositeSin(zAngle, tickLength));

														xTicks.append("text")
															.attr("class", "axis-label")
															.text(function (d) { return d; })
															.style("fill", "#fff")
															.attr("x", adjacentCos(zAngle, tickText))
															.attr("y", oppositeSin(zAngle, tickText));
													};
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/HarryStevens/974ee8aadb9d1676d62202ef5e367577 */}}
													<h3 class="card-title">Joyplot chart - 3</h3>
												</div>
												<div class="card-body">
													<div id="jc3" style="height: auto">
													</div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var alpha = "Annie,Bob,Christina,Dylan".split(",");

													var margin = { top: 50, left: 75, bottom: 50, right: 20 },
														width = 712 - margin.left - margin.right,
														height = 300 - margin.top - margin.bottom;
													var svg = d3.select("#jc3").append("svg")
														.attr("width", width + margin.left + margin.right)
														.attr("height", height + margin.top + margin.bottom)
														.append("g")
														.attr("transform", "translate(" + margin.left + ", " + margin.top + ")");
													var y_wrapper = d3.scaleBand().rangeRound([0, height]).domain(alpha),
														y = d3.scaleLinear().range([y_wrapper.bandwidth(), 0]).domain([0, 100]),
														x = d3.scaleLinear().range([0, width]).domain([0, 100]),
														color = d3.scaleOrdinal(d3.schemeCategory10);
													var area = d3.area()
														.x(function (d) { return x(d.day); })
														.y1(function (d) { return y(d.value * 2); })
														.y0(y(0))
														.curve(d3.curveBasis);
													var line = d3.line()
														.x(function (d) { return x(d.day); })
														.y(function (d) { return y(d.value * 2); })
														.curve(d3.curveBasis);

													color.domain(alpha);
													
													svg.append("g")
														.attr("class", "axis x")
														.attr("transform", "translate(0, " + (height - 2) + ")")
														.call(d3.axisBottom(x))
													var data = [
														{ "id": "Annie", "data": [{ day: 0, value: 89 }, { day: 1, value: 40 }, { day: 2, value: 39 }, { day: 3, value: 17 }, { day: 4, value: 45 }, { day: 5, value: 49 }, { day: 6, value: 30 }, { day: 7, value: 88 }, { day: 8, value: 61 }, { day: 9, value: 72 }, { day: 10, value: 76 }, { day: 11, value: 86 }, { day: 12, value: 29 }, { day: 13, value: 18 }, { day: 14, value: 30 }, { day: 15, value: 16 }, { day: 16, value: 45 }, { day: 17, value: 65 }, { day: 18, value: 37 }, { day: 19, value: 55 }, { day: 20, value: 11 }, { day: 21, value: 64 }, { day: 22, value: 44 }, { day: 23, value: 39 }, { day: 24, value: 30 }, { day: 25, value: 65 }, { day: 26, value: 31 }, { day: 27, value: 12 }, { day: 28, value: 10 }, { day: 29, value: 65 }, { day: 30, value: 53 }, { day: 31, value: 28 }, { day: 32, value: 47 }, { day: 33, value: 74 }, { day: 34, value: 26 }, { day: 35, value: 66 }, { day: 36, value: 76 }, { day: 37, value: 66 }, { day: 38, value: 34 }, { day: 39, value: 88 }, { day: 40, value: 24 }, { day: 41, value: 76 }, { day: 42, value: 16 }, { day: 43, value: 14 }, { day: 44, value: 31 }, { day: 45, value: 18 }, { day: 46, value: 61 }, { day: 47, value: 52 }, { day: 48, value: 60 }, { day: 49, value: 85 }, { day: 50, value: 53 }, { day: 51, value: 51 }, { day: 52, value: 53 }, { day: 53, value: 52 }, { day: 54, value: 12 }, { day: 55, value: 85 }, { day: 56, value: 61 }, { day: 57, value: 78 }, { day: 58, value: 42 }, { day: 59, value: 77 }, { day: 60, value: 55 }, { day: 61, value: 21 }, { day: 62, value: 29 }, { day: 63, value: 66 }, { day: 64, value: 11 }, { day: 65, value: 81 }, { day: 66, value: 64 }, { day: 67, value: 65 }, { day: 68, value: 22 }, { day: 69, value: 61 }, { day: 70, value: 10 }, { day: 71, value: 14 }, { day: 72, value: 45 }, { day: 73, value: 14 }, { day: 74, value: 19 }, { day: 75, value: 44 }, { day: 76, value: 50 }, { day: 77, value: 43 }, { day: 78, value: 55 }, { day: 79, value: 33 }, { day: 80, value: 77 }, { day: 81, value: 86 }, { day: 82, value: 37 }, { day: 83, value: 83 }, { day: 84, value: 61 }, { day: 85, value: 44 }, { day: 86, value: 12 }, { day: 87, value: 74 }, { day: 88, value: 54 }, { day: 89, value: 53 }, { day: 90, value: 10 }, { day: 91, value: 71 }, { day: 92, value: 21 }, { day: 93, value: 29 }, { day: 94, value: 36 }, { day: 95, value: 35 }, { day: 96, value: 88 }, { day: 97, value: 23 }, { day: 98, value: 51 }, { day: 99, value: 28 }, { day: 100, value: 52 }] },
														{ "id": "Bob", "data": [{ day: 0, value: 37 }, { day: 1, value: 70 }, { day: 2, value: 44 }, { day: 3, value: 71 }, { day: 4, value: 70 }, { day: 5, value: 66 }, { day: 6, value: 58 }, { day: 7, value: 38 }, { day: 8, value: 37 }, { day: 9, value: 67 }, { day: 10, value: 42 }, { day: 11, value: 10 }, { day: 12, value: 16 }, { day: 13, value: 89 }, { day: 14, value: 57 }, { day: 15, value: 32 }, { day: 16, value: 22 }, { day: 17, value: 10 }, { day: 18, value: 20 }, { day: 19, value: 41 }, { day: 20, value: 38 }, { day: 21, value: 74 }, { day: 22, value: 43 }, { day: 23, value: 79 }, { day: 24, value: 83 }, { day: 25, value: 42 }, { day: 26, value: 50 }, { day: 27, value: 87 }, { day: 28, value: 88 }, { day: 29, value: 77 }, { day: 30, value: 42 }, { day: 31, value: 89 }, { day: 32, value: 34 }, { day: 33, value: 31 }, { day: 34, value: 37 }, { day: 35, value: 74 }, { day: 36, value: 68 }, { day: 37, value: 47 }, { day: 38, value: 68 }, { day: 39, value: 56 }, { day: 40, value: 63 }, { day: 41, value: 46 }, { day: 42, value: 25 }, { day: 43, value: 49 }, { day: 44, value: 69 }, { day: 45, value: 82 }, { day: 46, value: 35 }, { day: 47, value: 13 }, { day: 48, value: 81 }, { day: 49, value: 47 }, { day: 50, value: 85 }, { day: 51, value: 13 }, { day: 52, value: 76 }, { day: 53, value: 68 }, { day: 54, value: 50 }, { day: 55, value: 26 }, { day: 56, value: 43 }, { day: 57, value: 86 }, { day: 58, value: 50 }, { day: 59, value: 89 }, { day: 60, value: 13 }, { day: 61, value: 56 }, { day: 62, value: 51 }, { day: 63, value: 83 }, { day: 64, value: 25 }, { day: 65, value: 68 }, { day: 66, value: 59 }, { day: 67, value: 10 }, { day: 68, value: 17 }, { day: 69, value: 48 }, { day: 70, value: 19 }, { day: 71, value: 35 }, { day: 72, value: 42 }, { day: 73, value: 19 }, { day: 74, value: 56 }, { day: 75, value: 68 }, { day: 76, value: 60 }, { day: 77, value: 33 }, { day: 78, value: 22 }, { day: 79, value: 83 }, { day: 80, value: 20 }, { day: 81, value: 36 }, { day: 82, value: 18 }, { day: 83, value: 23 }, { day: 84, value: 19 }, { day: 85, value: 75 }, { day: 86, value: 32 }, { day: 87, value: 47 }, { day: 88, value: 15 }, { day: 89, value: 73 }, { day: 90, value: 54 }, { day: 91, value: 18 }, { day: 92, value: 59 }, { day: 93, value: 38 }, { day: 94, value: 84 }, { day: 95, value: 12 }, { day: 96, value: 39 }, { day: 97, value: 77 }, { day: 98, value: 41 }, { day: 99, value: 84 }, { day: 100, value: 19 }] },
														{ "id": "Christina", "data": [{ day: 0, value: 81 }, { day: 1, value: 49 }, { day: 2, value: 52 }, { day: 3, value: 78 }, { day: 4, value: 36 }, { day: 5, value: 70 }, { day: 6, value: 24 }, { day: 7, value: 64 }, { day: 8, value: 13 }, { day: 9, value: 84 }, { day: 10, value: 34 }, { day: 11, value: 16 }, { day: 12, value: 47 }, { day: 13, value: 30 }, { day: 14, value: 89 }, { day: 15, value: 57 }, { day: 16, value: 18 }, { day: 17, value: 84 }, { day: 18, value: 58 }, { day: 19, value: 32 }, { day: 20, value: 10 }, { day: 21, value: 51 }, { day: 22, value: 83 }, { day: 23, value: 62 }, { day: 24, value: 72 }, { day: 25, value: 49 }, { day: 26, value: 87 }, { day: 27, value: 13 }, { day: 28, value: 33 }, { day: 29, value: 10 }, { day: 30, value: 18 }, { day: 31, value: 56 }, { day: 32, value: 51 }, { day: 33, value: 82 }, { day: 34, value: 24 }, { day: 35, value: 65 }, { day: 36, value: 51 }, { day: 37, value: 85 }, { day: 38, value: 85 }, { day: 39, value: 28 }, { day: 40, value: 80 }, { day: 41, value: 59 }, { day: 42, value: 41 }, { day: 43, value: 20 }, { day: 44, value: 16 }, { day: 45, value: 34 }, { day: 46, value: 82 }, { day: 47, value: 87 }, { day: 48, value: 11 }, { day: 49, value: 79 }, { day: 50, value: 25 }, { day: 51, value: 53 }, { day: 52, value: 21 }, { day: 53, value: 77 }, { day: 54, value: 34 }, { day: 55, value: 35 }, { day: 56, value: 71 }, { day: 57, value: 84 }, { day: 58, value: 16 }, { day: 59, value: 75 }, { day: 60, value: 25 }, { day: 61, value: 72 }, { day: 62, value: 39 }, { day: 63, value: 24 }, { day: 64, value: 76 }, { day: 65, value: 41 }, { day: 66, value: 56 }, { day: 67, value: 21 }, { day: 68, value: 78 }, { day: 69, value: 72 }, { day: 70, value: 53 }, { day: 71, value: 47 }, { day: 72, value: 63 }, { day: 73, value: 17 }, { day: 74, value: 49 }, { day: 75, value: 18 }, { day: 76, value: 70 }, { day: 77, value: 34 }, { day: 78, value: 16 }, { day: 79, value: 57 }, { day: 80, value: 70 }, { day: 81, value: 51 }, { day: 82, value: 11 }, { day: 83, value: 76 }, { day: 84, value: 72 }, { day: 85, value: 17 }, { day: 86, value: 35 }, { day: 87, value: 88 }, { day: 88, value: 39 }, { day: 89, value: 72 }, { day: 90, value: 88 }, { day: 91, value: 52 }, { day: 92, value: 72 }, { day: 93, value: 26 }, { day: 94, value: 44 }, { day: 95, value: 12 }, { day: 96, value: 74 }, { day: 97, value: 35 }, { day: 98, value: 57 }, { day: 99, value: 79 }, { day: 100, value: 60 }] },
														{ "id": "Dylan", "data": [{ day: 0, value: 75 }, { day: 1, value: 32 }, { day: 2, value: 16 }, { day: 3, value: 19 }, { day: 4, value: 28 }, { day: 5, value: 39 }, { day: 6, value: 71 }, { day: 7, value: 80 }, { day: 8, value: 88 }, { day: 9, value: 73 }, { day: 10, value: 15 }, { day: 11, value: 80 }, { day: 12, value: 29 }, { day: 13, value: 46 }, { day: 14, value: 40 }, { day: 15, value: 64 }, { day: 16, value: 21 }, { day: 17, value: 28 }, { day: 18, value: 82 }, { day: 19, value: 23 }, { day: 20, value: 29 }, { day: 21, value: 18 }, { day: 22, value: 29 }, { day: 23, value: 35 }, { day: 24, value: 19 }, { day: 25, value: 32 }, { day: 26, value: 33 }, { day: 27, value: 33 }, { day: 28, value: 80 }, { day: 29, value: 68 }, { day: 30, value: 61 }, { day: 31, value: 87 }, { day: 32, value: 37 }, { day: 33, value: 68 }, { day: 34, value: 17 }, { day: 35, value: 79 }, { day: 36, value: 82 }, { day: 37, value: 69 }, { day: 38, value: 61 }, { day: 39, value: 47 }, { day: 40, value: 46 }, { day: 41, value: 90 }, { day: 42, value: 78 }, { day: 43, value: 76 }, { day: 44, value: 64 }, { day: 45, value: 27 }, { day: 46, value: 73 }, { day: 47, value: 58 }, { day: 48, value: 90 }, { day: 49, value: 26 }, { day: 50, value: 58 }, { day: 51, value: 85 }, { day: 52, value: 69 }, { day: 53, value: 88 }, { day: 54, value: 29 }, { day: 55, value: 17 }, { day: 56, value: 53 }, { day: 57, value: 27 }, { day: 58, value: 71 }, { day: 59, value: 73 }, { day: 60, value: 33 }, { day: 61, value: 81 }, { day: 62, value: 77 }, { day: 63, value: 39 }, { day: 64, value: 81 }, { day: 65, value: 54 }, { day: 66, value: 17 }, { day: 67, value: 70 }, { day: 68, value: 37 }, { day: 69, value: 38 }, { day: 70, value: 85 }, { day: 71, value: 73 }, { day: 72, value: 52 }, { day: 73, value: 29 }, { day: 74, value: 55 }, { day: 75, value: 45 }, { day: 76, value: 25 }, { day: 77, value: 89 }, { day: 78, value: 44 }, { day: 79, value: 19 }, { day: 80, value: 62 }, { day: 81, value: 49 }, { day: 82, value: 32 }, { day: 83, value: 24 }, { day: 84, value: 69 }, { day: 85, value: 14 }, { day: 86, value: 84 }, { day: 87, value: 39 }, { day: 88, value: 64 }, { day: 89, value: 23 }, { day: 90, value: 25 }, { day: 91, value: 66 }, { day: 92, value: 52 }, { day: 93, value: 23 }, { day: 94, value: 11 }, { day: 95, value: 69 }, { day: 96, value: 73 }, { day: 97, value: 35 }, { day: 98, value: 22 }, { day: 99, value: 48 }, { day: 100, value: 89 }] }
													]

													// labels
													svg.selectAll(".line-label")
														.data(data, function (d) { return d.id; })
														.enter().append("text")
														.attr("class", "line-label")
														.style("fill", "#999")
														.attr("x", -margin.left + 5)
														.attr("y", function (d) { return y_wrapper(d.id) + y_wrapper.bandwidth() - 3; })
														.text(function (d) { return d.id; });

													// baselines
													svg.selectAll(".baseline")
														.data(data, function (d) { return d.id; })
														.enter().append("line")
														.attr("class", "baseline")
														.attr("x1", 0)
														.attr("x2", width)
														.attr("y1", function (d) { return y_wrapper(d.id) + y_wrapper.bandwidth(); })
														.attr("y2", function (d) { return y_wrapper(d.id) + y_wrapper.bandwidth(); });

													// JOIN
													var area_path = svg.selectAll(".area")
														.data(data, function (d) { return d.id; });
													var line_path = svg.selectAll(".line")
														.data(data, function (d) { return d.id; });

													// UDATE
													area_path.transition()
														.attr("d", function (d) { return area(d.data); });

													// ENTER
													area_path.enter().append("path")
														.attr("class", function (d) { return "area " + d.id; })
														.attr("transform", function (d) { return "translate(0, " + (y_wrapper(d.id) - 1.5) + ")"; })
														.attr("d", function (d) { return area(d.data); })
														.attr("fill", function (d) { return color(d.id); })
														.attr("opacity", "0.5");
													line_path.enter().append("path")
														.attr("class", function (d) { return "line " + d.id; })
														.attr("transform", function (d) { return "translate(0, " + (y_wrapper(d.id) - 1.5) + ")"; })
														.attr("d", function (d) { return line(d.data); })
														.attr("stroke", function (d) { return color(d.id); })
														.attr("stroke-width", "1.5px")
														.attr("fill", "none");
													});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/sajudson/a0713fb9826aea45f15b207dfec9bcb4 */}}
													<h3 class="card-title">Multiple line with brush and zoom chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="mlwbzc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													const xLabel = 'Date';
													const yLabel = 'Users';

													var svg = d3.select("#mlwbzc1").append("svg").attr("width", 712).attr("height", 300),
														margin = { top: 20, right: 80, bottom: 110, left: 80 },
														margin2 = { top: 430, right: 80, bottom: 30, left: 80 },
														width = +svg.attr("width") - margin.left - margin.right,
														height = +svg.attr("height") - margin.top - margin.bottom,
														height2 = +svg.attr("height") - margin2.top - margin2.bottom;

													var parseDate = d3.timeParse("%b %Y");

													var x = d3.scaleTime().range([0, width]),
														x2 = d3.scaleTime().range([0, width]),
														y = d3.scaleLinear().range([height, 0]),
														y2 = d3.scaleLinear().range([height2, 0]);

													var xAxis = d3.axisBottom(x),
														xAxis2 = d3.axisBottom(x2),
														yAxis = d3.axisLeft(y);

													var brush = d3.brushX()
														.extent([[0, 0], [width, height2]])
														.on("brush end", brushed);

													var zoom = d3.zoom()
														.scaleExtent([1, Infinity])
														.translateExtent([[0, 0], [width, height]])
														.extent([[0, 0], [width, height]])
														.on("zoom", zoomed);
													var line = d3.line()
														.x(function (d) { return x(d.date); })
														.y(function (d) { return y(d.price); });
													// var line = d3.line()
													// 	.curve(d3.curveCatmullRom)
													// 	.x(function (d) { return x(d.dteday); })
													// 	.y(function (d) { return y(d.cnt); });

													// var lineCasual = d3.line()
													// 	.curve(d3.curveCatmullRom)
													// 	.x(function (d) { return x(d.dteday); })
													// 	.y(function (d) { return y(d.casual); });

													// var lineTemp = d3.line()
													// 	.curve(d3.curveCatmullRom)
													// 	.x(function (d) { return x(d.dteday); })
													// 	.y(function (d) { return yRight(d.temp); });

													// var lineRegistered = d3.line()
													// 	.curve(d3.curveCatmullRom)
													// 	.x(function (d) { return x(d.dteday); })
													// 	.y(function (d) { return y(d.registered); });

													// var lineTotal = d3.line()
													// 	.curve(d3.curveCatmullRom)
													// 	.x(function (d) { return x2(d.dteday); })
													// 	.y(function (d) { return y2(d.cnt); });


													svg.append("defs").append("clipPath")
														.attr("id", "clip")
														.append("rect")
														.attr("width", width)
														.attr("height", height);

													var focus = svg.append("g")
														.attr("class", "focus")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

													var context = svg.append("g")
														.attr("class", "context")
														.attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

													var dataset = d3.tsv("/demo/stocks.tsv", function (data) {
														return data;
													});
													dataset.then(function (data) {
														return data.map(function (d) {
															d.date = parseDate(d.date);
															d.price = +d.price;
															return d;
														});
													}).then(function (data) {
														x.domain(d3.extent(data, function (d) { return d.date; }));
														y.domain([0, d3.max(data, function (d) { return d.price; })]);
														x2.domain(x.domain());
														y2.domain(y.domain());

														// focus.append("path")
														// 	.datum(data)
														// 	.attr("class", "line line_casual")
														// 	.attr("d", lineCasual);

														// focus.append("path")
														// 	.datum(data)
														// 	.attr("class", "line line_registered")
														// 	.attr("d", lineRegistered);

														// focus.append("path")
														// 	.datum(data)
														// 	.attr("class", "line line_temp")
														// 	.attr("d", lineTemp);
														// Nest the entries by symbol
														var nest = d3.nest()
															.key(function (d) { return d.symbol; })
															.entries(data);

														// set the colour scale
														var color = d3.scaleOrdinal(d3.schemeCategory10);
														// Loop through each symbol / key
														nest.map(function (d) {
															focus.append("path")
																.attr("stroke-width", "1.5px")
																.attr("fill", "none")
																.attr("stroke", function () { // Add the colours dynamically
																	return d.color = color(d.key);
																})
																.attr("d", line(d.values));
														});

														// Add the X Axis
														focus.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height + ")")
															.call(xAxis)
															.style("fill", "none")
															.style("stoke", "grey")
															.style("stoke-width", "1")
															.style("shape-rendering", "crispEdges");

														// Add the Y Axis
														focus.append("g")
															.attr("class", "axis axis--y")
															.call(yAxis)
															.style("fill", "none")
															.style("stoke", "grey")
															.style("stoke-width", "1")
															.style("shape-rendering", "crispEdges")
															.append('text')
															.attr('class', 'axis-label')
															.attr('x', -height / 2)
															.attr('y', -50)
															.attr('transform', `rotate(-90)`)
															.style('text-anchor', 'middle')
															.text(yLabel);

														// context.append("path")
														// 	.datum(data)
														// 	.attr("class", "line_total")
														// 	.attr("d", lineTotal);

														context.append("g")
															.attr("class", "axis axis--x")
															.attr("transform", "translate(0," + height2 + ")")
															.call(xAxis2);

														context.append("g")
															.attr("class", "brush")
															.call(brush)
															.call(brush.move, x.range());

														svg.append("rect")
															.attr("class", "zoom")
															.attr("width", width)
															.attr("height", height)
															.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
															.call(zoom);
													});

													function brushed() {
														if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
														var s = d3.event.selection || x2.range();
														x.domain(s.map(x2.invert, x2));
														// focus.selectAll(".line_casual").attr("d", lineCasual);
														// focus.select(".line_registered").attr("d", lineRegistered);
														// focus.select(".line_temp").attr("d", lineTemp);
														focus.select(".axis--x").call(xAxis);
														svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
															.scale(width / (s[1] - s[0]))
															.translate(-s[0], 0));
													}

													function zoomed() {
														if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
														var t = d3.event.transform;
														x.domain(t.rescaleX(x2).domain());
														// focus.select(".line_casual").attr("d", lineCasual);
														// focus.select(".line_registered").attr("d", lineRegistered);
														// focus.select(".line_temp").attr("d", lineTemp);
														focus.select(".axis--x").call(xAxis);
														context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
													}
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* url */}}
													<h3 class="card-title">Bi-Direction stream chart</h3>
												</div>
												<div class="card-body">
													<div id="bdsc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/mbostock/8d2112a115ad95f4a6848001389182fb */}}
													<h3 class="card-title">Radial stacked bar chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="rsbc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													// (function (global, factory) {
													// 	typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("d3-scale")) :
													// 		typeof define === "function" && define.amd ? define(["exports", "d3-scale"], factory) :
													// 			(factory(global.d3 = global.d3 || {}, global.d3));
													// }(this, function (exports, d3Scale) {
													// 	'use strict';

													// 	function square(x)
													// 	{
													// 		return x * x;
													// 	}
													// 	function radial()
													// 	{
													// 		var linear = d3Scale.scaleLinear();
													// 		function scale(x)
													// 		{
													// 			return Math.sqrt(linear(x));
													// 		}
													// 		scale.domain = function (_)
													// 		{
													// 			return arguments.length ? (linear.domain(_), scale) : linear.domain();
													// 		};
													// 		scale.nice = function (count)
													// 		{
													// 			return (linear.nice(count), scale);
													// 		};
													// 		scale.range = function (_)
													// 		{
													// 			return arguments.length ? (linear.range(_.map(square)), scale) : linear.range().map(Math.sqrt);
													// 		};
													// 		scale.ticks = linear.ticks;
													// 		scale.tickFormat = linear.tickFormat;
													// 		return scale;
													// 	}
													// 	exports.scaleRadial = radial;
													// 	Object.defineProperty(exports, '__esModule', { value: true });
													// }));
													var svg = d3.select("#rsbc1").append("svg").attr("width", 712).attr("height", 712),
														width = +svg.attr("width"),
														height = +svg.attr("height"),
														innerRadius = 180,
														outerRadius = Math.min(width, height) / 2 - 6;
													var g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

													// var x = d3.scaleBand()
													// 	.range([0, 2 * Math.PI])
													// 	.align(0);

													// var y = d3.scaleRadial()
													// 	.range([innerRadius, outerRadius]);

													// var z = d3.scaleOrdinal()
													// 	.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													// var dataset = d3.csv("/demo/population.csv", function (data) {
													// 	return data;
													// });
													// dataset.then(function (data) {
													// 	//keys = data.columns.slice(1);
													// 	return data.map(function (d) {
													// 		var total = 0;
													// 		for (i = 1; i < data.columns.length; ++i) {
													// 			total += d[data.columns[i]] = +d[data.columns[i]];
													// 		}
													// 		d.Total = total;
													// 		return d;
													// 	});
													// }).then(function (data) {
													// 	data.sort(function (a, b) { return b[data.columns[1]] / b.Total - a[data.columns[1]] / a.Total; });
													// 	x.domain(data.map(function (d) { return d.State; }));
													// 	z.domain(data.columns.slice(1));

													// 	g.append("g")
													// 		.selectAll("g")
													// 		.data(d3.stack()
													// 			.keys(data.columns.slice(1))
													// 			.offset(d3.stackOffsetExpand)
													// 			(data))
													// 		.enter().append("g")
													// 		.attr("fill", function (d) { return z(d.key); })
													// 		.selectAll("path")
													// 		.data(function (d) { return d; })
													// 		.enter().append("path")
													// 		.attr("d", d3.arc()
													// 			.innerRadius(function (d) { return y(d[0]); })
													// 			.outerRadius(function (d) { return y(d[1]); })
													// 			.startAngle(function (d) { return x(d.data.State); })
													// 			.endAngle(function (d) { return x(d.data.State) + x.bandwidth(); })
													// 			.padAngle(0.01)
													// 			.padRadius(innerRadius));

													// 	var label = g.append("g")
													// 		.selectAll("g")
													// 		.data(data)
													// 		.enter().append("g")
													// 		.attr("text-anchor", "middle")
													// 		.attr("transform", function (d) { return "rotate(" + ((x(d.State) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")translate(" + innerRadius + ",0)"; });

													// 	label.append("line")
													// 		.attr("x2", -5)
													// 		.attr("stroke", "#000");

													// 	label.append("text")
													// 		.attr("transform", function (d) { return (x(d.State) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ? "rotate(90)translate(0,16)" : "rotate(-90)translate(0,-9)"; })
													// 		.text(function (d) { return d.State; });

													// 	var yAxis = g.append("g")
													// 		.attr("text-anchor", "middle");

													// 	var yTick = yAxis
													// 		.selectAll("g")
													// 		.data(y.ticks(5).slice(1))
													// 		.enter().append("g");

													// 	yTick.append("circle")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "#000")
													// 		.attr("r", y);

													// 	yTick.append("text")
													// 		.attr("y", function (d) { return -y(d); })
													// 		.attr("dy", "0.35em")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "#fff")
													// 		.attr("stroke-width", 5)
													// 		.attr("stroke-linejoin", "round")
													// 		.text(y.tickFormat(5, "%"));

													// 	yTick.append("text")
													// 		.attr("y", function (d) { return -y(d); })
													// 		.attr("dy", "0.35em")
													// 		.text(y.tickFormat(5, "%"));

													// 	var legend = g.append("g")
													// 		.selectAll("g")
													// 		.data(data.columns.slice(1).reverse())
													// 		.enter().append("g")
													// 		.attr("transform", function (d, i) { return "translate(-40," + (i - (data.columns.length - 1) / 2) * 20 + ")"; });

													// 	legend.append("rect")
													// 		.attr("width", 18)
													// 		.attr("height", 18)
													// 		.attr("fill", z);

													// 	legend.append("text")
													// 		.attr("x", 24)
													// 		.attr("y", 9)
													// 		.attr("dy", "0.35em")
													// 		.text(function (d) { return d; });
													// });
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/mbostock/6fead6d1378d6df5ae77bb6a719afcb2 */}}
													<h3 class="card-title">Radial stacked bar chart - 2</h3>
												</div>
												<div class="card-body">
													<div id="rsbc2" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													// (function (global, factory) {
													// 	typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("d3-scale")) :
													// 		typeof define === "function" && define.amd ? define(["exports", "d3-scale"], factory) :
													// 			(factory(global.d3 = global.d3 || {}, global.d3));
													// }(this, function (exports, d3Scale) {
													// 	'use strict';

													// 	function square(x)
													// 	{
													// 		return x * x;
													// 	}
													// 	function radial()
													// 	{
													// 		var linear = d3Scale.scaleLinear();
													// 		function scale(x)
													// 		{
													// 			return Math.sqrt(linear(x));
													// 		}
													// 		scale.domain = function (_)
													// 		{
													// 			return arguments.length ? (linear.domain(_), scale) : linear.domain();
													// 		};
													// 		scale.nice = function (count)
													// 		{
													// 			return (linear.nice(count), scale);
													// 		};
													// 		scale.range = function (_)
													// 		{
													// 			return arguments.length ? (linear.range(_.map(square)), scale) : linear.range().map(Math.sqrt);
													// 		};
													// 		scale.ticks = linear.ticks;
													// 		scale.tickFormat = linear.tickFormat;
													// 		return scale;
													// 	}
													// 	exports.scaleRadial = radial;
													// 	Object.defineProperty(exports, '__esModule', { value: true });
													// }));
													var svg = d3.select("#rsbc2").append("svg").attr("width", "712").attr("height", "712"),
														width = +svg.attr("width"),
														height = +svg.attr("height"),
														innerRadius = 180,
														outerRadius = Math.min(width, height) / 2;
													var g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

													// var x = d3.scaleBand()
													// 	.range([0, 2 * Math.PI])
													// 	.align(0);

													// var y = d3.scaleRadial()
													// 	.range([innerRadius, outerRadius]);

													// var z = d3.scaleOrdinal()
													// 	.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

													// d3.csv("data.csv", function (d, i, columns) {
													// 	for (i = 1, t = 0; i < columns.length; ++i) t += d[columns[i]] = +d[columns[i]];
													// 	d.total = t;
													// 	return d;
													// }, function (error, data) {
													// 	if (error) throw error;

													// 	x.domain(data.map(function (d) { return d.State; }));
													// 	y.domain([0, d3.max(data, function (d) { return d.total; })]);
													// 	z.domain(data.columns.slice(1));

													// 	g.append("g")
													// 		.selectAll("g")
													// 		.data(d3.stack().keys(data.columns.slice(1))(data))
													// 		.enter().append("g")
													// 		.attr("fill", function (d) { return z(d.key); })
													// 		.selectAll("path")
													// 		.data(function (d) { return d; })
													// 		.enter().append("path")
													// 		.attr("d", d3.arc()
													// 			.innerRadius(function (d) { return y(d[0]); })
													// 			.outerRadius(function (d) { return y(d[1]); })
													// 			.startAngle(function (d) { return x(d.data.State); })
													// 			.endAngle(function (d) { return x(d.data.State) + x.bandwidth(); })
													// 			.padAngle(0.01)
													// 			.padRadius(innerRadius));

													// 	var label = g.append("g")
													// 		.selectAll("g")
													// 		.data(data)
													// 		.enter().append("g")
													// 		.attr("text-anchor", "middle")
													// 		.attr("transform", function (d) { return "rotate(" + ((x(d.State) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")translate(" + innerRadius + ",0)"; });

													// 	label.append("line")
													// 		.attr("x2", -5)
													// 		.attr("stroke", "#000");

													// 	label.append("text")
													// 		.attr("transform", function (d) { return (x(d.State) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ? "rotate(90)translate(0,16)" : "rotate(-90)translate(0,-9)"; })
													// 		.text(function (d) { return d.State; });

													// 	var yAxis = g.append("g")
													// 		.attr("text-anchor", "middle");

													// 	var yTick = yAxis
													// 		.selectAll("g")
													// 		.data(y.ticks(5).slice(1))
													// 		.enter().append("g");

													// 	yTick.append("circle")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "#000")
													// 		.attr("r", y);

													// 	yTick.append("text")
													// 		.attr("y", function (d) { return -y(d); })
													// 		.attr("dy", "0.35em")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "#fff")
													// 		.attr("stroke-width", 5)
													// 		.text(y.tickFormat(5, "s"));

													// 	yTick.append("text")
													// 		.attr("y", function (d) { return -y(d); })
													// 		.attr("dy", "0.35em")
													// 		.text(y.tickFormat(5, "s"));

													// 	yAxis.append("text")
													// 		.attr("y", function (d) { return -y(y.ticks(5).pop()); })
													// 		.attr("dy", "-1em")
													// 		.text("Population");

													// 	var legend = g.append("g")
													// 		.selectAll("g")
													// 		.data(data.columns.slice(1).reverse())
													// 		.enter().append("g")
													// 		.attr("transform", function (d, i) { return "translate(-40," + (i - (data.columns.length - 1) / 2) * 20 + ")"; });

													// 	legend.append("rect")
													// 		.attr("width", 18)
													// 		.attr("height", 18)
													// 		.attr("fill", z);

													// 	legend.append("text")
													// 		.attr("x", 24)
													// 		.attr("y", 9)
													// 		.attr("dy", "0.35em")
													// 		.text(function (d) { return d; });
													// });
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/tlfrd/fd6991b2d1947a3cb9e0bd20053899d6 */}}
													<h3 class="card-title">Radial line chart - 1</h3>
												</div>
												<div class="card-body">
													<div id="rlc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													// (function (global, factory) {
													// 	typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("d3-scale")) :
													// 		typeof define === "function" && define.amd ? define(["exports", "d3-scale"], factory) :
													// 			(factory(global.d3 = global.d3 || {}, global.d3));
													// }(this, function (exports, d3Scale) {
													// 	'use strict';

													// 	function square(x)
													// 	{
													// 		return x * x;
													// 	}
													// 	function radial()
													// 	{
													// 		var linear = d3Scale.scaleLinear();
													// 		function scale(x)
													// 		{
													// 			return Math.sqrt(linear(x));
													// 		}
													// 		scale.domain = function (_)
													// 		{
													// 			return arguments.length ? (linear.domain(_), scale) : linear.domain();
													// 		};
													// 		scale.nice = function (count)
													// 		{
													// 			return (linear.nice(count), scale);
													// 		};
													// 		scale.range = function (_)
													// 		{
													// 			return arguments.length ? (linear.range(_.map(square)), scale) : linear.range().map(Math.sqrt);
													// 		};
													// 		scale.ticks = linear.ticks;
													// 		scale.tickFormat = linear.tickFormat;
													// 		return scale;
													// 	}
													// 	exports.scaleRadial = radial;
													// 	Object.defineProperty(exports, '__esModule', { value: true });
													// }));
													var margin = { top: 20, right: 10, bottom: 20, left: 10 };
													var width = 712 - margin.left - margin.right,
														height = 712 - margin.top - margin.bottom;
													var svg = d3.select("#rlc1").append("svg")
														.attr("width", width + margin.left + margin.right)
														.attr("height", height + margin.top + margin.bottom)
														.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
													// var g = svg.append("g")
													// 	.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
													// var innerRadius = 100,
													// 	outerRadius = Math.min(width, height) / 2 - 6;
													// var parseTime = d3.timeParse("%d-%b-%y");
													// var formatMonth = d3.timeFormat("%b");
													// var fullCircle = 2 * Math.PI;
													// var x = d3.scaleTime().range([0, fullCircle]);
													// var y = d3.scaleRadial().range([innerRadius, outerRadius]);
													// var line = d3.lineRadial()
													// 	.angle(function (d) { return x(d.Date); })
													// 	.radius(function (d) { return y(d.Close); });

													// d3.csv("/demo/calendar.csv", function (data) {
													// 	return data;
													// }).then(function (data) {
													// 	data.Date = parseTime(data.Date);
													// 	data.Close = +data.Close;
													// 	return data;
													// }).then(function (data) {
													// 	x.domain(d3.extent(data, function (d) { return d.Date; }));
													// 	y.domain(d3.extent(data, function (d) { return d.Close; }));

													// 	var linePlot = g.append("path")
													// 		.datum(data)
													// 		.attr("fill", "none")
													// 		.attr("stroke", "#4099ff")
													// 		.attr("d", line);

													// 	var yAxis = g.append("g")
													// 		.attr("text-anchor", "middle");

													// 	var yTick = yAxis
													// 		.selectAll("g")
													// 		.data(y.ticks(5))
													// 		.enter().append("g");

													// 	yTick.append("circle")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "black")
													// 		.attr("opacity", 0.2)
													// 		.attr("r", y);

													// 	yAxis.append("circle")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "black")
													// 		.attr("opacity", 0.2)
													// 		.attr("r", function () { return y(y.domain()[0]) });

													// 	var labels = yTick.append("text")
													// 		.attr("y", function (d) { return -y(d); })
													// 		.attr("dy", "0.35em")
													// 		.attr("fill", "none")
													// 		.attr("stroke", "#fff")
													// 		.attr("stroke-width", 5)
													// 		.attr("stroke-linejoin", "round")
													// 		.text(function (d) { return "$" + d; });

													// 	yTick.append("text")
													// 		.attr("y", function (d) { return -y(d); })
													// 		.attr("dy", "0.35em")
													// 		.text(function (d) { return "$" + d; });

													// 	var xAxis = g.append("g");

													// 	var xTick = xAxis
													// 		.selectAll("g")
													// 		.data(x.ticks(12))
													// 		.enter().append("g")
													// 		.attr("text-anchor", "middle")
													// 		.attr("transform", function (d) {
													// 			return "rotate(" + ((x(d)) * 180 / Math.PI - 90) + ")translate(" + innerRadius + ",0)";
													// 		});

													// 	xTick.append("line").attr("x2", -5).attr("stroke", "#000");

													// 	xTick.append("text")
													// 		.attr("transform", function (d) {
													// 			var angle = x(d);
													// 			return ((angle < Math.PI / 2) || (angle > (Math.PI * 3 / 2))) ? "rotate(90)translate(0,22)" : "rotate(-90)translate(0, -15)";
													// 		})
													// 		.text(function (d) { return formatMonth(d);})
													// 		.style("font-size", 10)
													// 		.attr("opacity", 0.6)

													// 	var title = g.append("g")
													// 		.attr("class", "title")
													// 		.append("text")
													// 		.attr("dy", "-0.2em")
													// 		.attr("text-anchor", "middle")
													// 		.text("Twitter")

													// 	var subtitle = g.append("text")
													// 		.attr("dy", "1em")
													// 		.attr("text-anchor", "middle")
													// 		.attr("opacity", 0.6)
													// 		.text("16/17");

													// 	var lineLength = linePlot.node().getTotalLength();

													// 	linePlot
													// 		.attr("stroke-dasharray", lineLength + " " + lineLength)
													// 		.attr("stroke-dashoffset", -lineLength)
													// 		.transition()
													// 		.duration(2000)
													// 		.ease(d3.easeLinear)
													// 		.attr("stroke-dashoffset", 0);
													// });
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://bl.ocks.org/nitaku/833632f23c308ae2d58b */}}
													<h3 class="card-title">Isometric treemap</h3>
												</div>
												<div class="card-body">
													<div id="treemap1" style="height: 20rem"></div>
												</div>
											</div>
											<style>
												.iso.outline {
													stroke: #333;
													fill: none;
													vector-effect: non-scaling-stroke;
												}
									
												.label {
													pointer-events: none;
													text-anchor: middle;
													font-family: Impact;
												}
									
												.pipedon:hover .label {
													fill: black;
												}
									
												.pipedon:hover .face {
													fill: yellow;
												}
									
												.hidden {
													display: none;
												}
											</style>
											<script>
												require(['d3'], function (d3) {
													var DH, PAD, color, correct_x, correct_y, height, iso_layout, isometric, ordering, parallelepipedon, path_generator, svg, treemap, vis, width, zoom, zoomable_layer;
													svg = d3.select("#treemap1").append("svg");
													width = svg.node().getBoundingClientRect().width;
													height = svg.node().getBoundingClientRect().height;
													zoomable_layer = svg.append('g');
													zoom = d3.zoom().scaleExtent([1, 100]).on('zoom', function () {
														return zoomable_layer.attr({
															transform: "translate(" + (zoom.translate()) + ")scale(" + (zoom.scale()) + ")"
														});
													});
													svg.call(zoom);
													vis = zoomable_layer.append('g').attr({
														"class": 'vis',
														transform: "translate(" + (width / 2) + "," + (height / 3 - 112) + ")"
													});

													isometric = function (_3d_p) {
														return [-Math.sqrt(3) / 2 * _3d_p[0] + Math.sqrt(3) / 2 * _3d_p[1], +0.5 * _3d_p[0] + 0.5 * _3d_p[1] - _3d_p[2]];
													};

													parallelepipedon = function (d) {
														var fb, ft, mlb, mlt, mrb, mrt, nb, nt;
														if (!(d.x != null)) {
															d.x = 0;
														}
														if (!(d.y != null)) {
															d.y = 0;
														}
														if (!(d.h != null)) {
															d.h = 0;
														}
														if (!(d.dx != null)) {
															d.dx = 10;
														}
														if (!(d.dy != null)) {
															d.dy = 10;
														}
														if (!(d.dh != null)) {
															d.dh = 10;
														}
														fb = isometric([d.x, d.y, d.h], mlb = isometric([d.x + d.dx, d.y, d.h], nb = isometric([d.x + d.dx, d.y + d.dy, d.h], mrb = isometric([d.x, d.y + d.dy, d.h], ft = isometric([d.x, d.y, d.h + d.dh], mlt = isometric([d.x + d.dx, d.y, d.h + d.dh], nt = isometric([d.x + d.dx, d.y + d.dy, d.h + d.dh], mrt = isometric([d.x, d.y + d.dy, d.h + d.dh]))))))));
														d.iso = {
															face_bottom: [fb, mrb, nb, mlb],
															face_left: [mlb, mlt, nt, nb],
															face_right: [nt, mrt, mrb, nb],
															face_top: [ft, mrt, nt, mlt],
															outline: [ft, mrt, mrb, nb, mlb, mlt],
															fb: fb,
															mlb: mlb,
															nb: nb,
															mrb: mrb,
															ft: ft,
															mlt: mlt,
															nt: nt,
															mrt: mrt
														};
														return d;
													};

													ordering = function (a, b) {
														return b.i - a.i;
													};

													iso_layout = function (data, shape, scale) {
														if (!(scale != null)) {
															scale = 1;
														}
														data.forEach(function (d) {
															return shape(d, scale);
														});
														return data.sort(ordering);
													};

													path_generator = function (d) {
														return 'M' + d.map(function (p) {
															return p.join(' ');
														}).join('L') + 'z';
													};

													DH = 5;
													PAD = 4;

													treemap = d3.treemap().size([400, 400]).padding(PAD).round(false);
													// .value(function (d) {
													// 	return d.size;
													// })
													// var root = d3.stratify()
													// 	.id(function (d) { return d.name; })
													// 	.parentId(function (d) { return d.parent; })
													// 	(table);
													// var nodes = treemap(root, sort(function (a, b) {
													// 	return ordering(b, a);
													// }));

													color = d3.scaleOrdinal(d3.schemeCategory20c);

													correct_x = d3.scaleLinear().domain([0, width]).range([0, width * 1.05]);

													correct_y = d3.scaleLinear().domain([0, height]).range([0, height * 3 / 4]);

													d3.json('/demo/flare.json', function (tree) {
														var data, enter_labels, enter_labels_g, enter_pipedons, i, pipedons, walk, walk_i;
														walk = function (n, depth) {
															var child, _i, _len, _ref;
															n.depth = depth;
															n.dh = DH;
															n.h = DH * depth;
															if (n.children != null) {
																_ref = n.children;
																for (_i = 0, _len = _ref.length; _i < _len; _i++) {
																	child = _ref[_i];
																	walk(child, depth + 1);
																}
																n.children.sort(function (a, b) {
																	return a.size - b.size;
																});
																return n.size = d3.sum(n.children, function (d) {
																	return d.size;
																});
															}
														};
														walk(tree, 0);
														i = 0;
														walk_i = function (n) {
															var child, _i, _len, _ref;
															if (n.children != null) {
																_ref = n.children;
																for (_i = 0, _len = _ref.length; _i < _len; _i++) {
																	child = _ref[_i];
																	walk_i(child);
																}
															}
															n.i = i;
															return i += 1;
														};
														walk_i(tree);
														data = treemap.nodes(tree);
														iso_layout(data, parallelepipedon);
														data.forEach(function (d, i) {
															return d.template_color = d3.hcl(color(d.i));
														});
														pipedons = vis.selectAll('.pipedon').data(data);
														enter_pipedons = pipedons.enter().append('g').attr({
															"class": 'pipedon'
														});
														enter_pipedons.append('path').attr({
															"class": 'iso face bottom',
															d: function (d) {
																return path_generator(d.iso.face_bottom);
															}
														});
														enter_pipedons.append('path').attr({
															"class": 'iso face left',
															d: function (d) {
																return path_generator(d.iso.face_left);
															},
															fill: function (d) {
																return d.template_color;
															}
														});
														enter_pipedons.append('path').attr({
															"class": 'iso face right',
															d: function (d) {
																return path_generator(d.iso.face_right);
															},
															fill: function (d) {
																return d3.hcl(d.template_color.h, d.template_color.c, d.template_color.l - 12);
															}
														});
														enter_pipedons.append('path').attr({
															"class": 'iso face top',
															d: function (d) {
																return path_generator(d.iso.face_top);
															},
															fill: function (d) {
																return d3.hcl(d.template_color.h, d.template_color.c, d.template_color.l + 12);
															}
														});
														enter_labels_g = enter_pipedons.append('g').classed('hidden', function (d) {
															return d.children != null;
														});
														enter_labels = enter_labels_g.append('svg').attr({
															"class": 'label'
														});
														enter_labels.append('text').text(function (d) {
															return d.name.toUpperCase();
														}).attr({
															dy: '.35em'
														}).each(function (node) {
															var bbox, bbox_aspect, node_bbox, node_bbox_aspect, rotate;
															bbox = this.getBBox();
															bbox_aspect = bbox.width / bbox.height;
															node_bbox = {
																width: node.dx,
																height: node.dy
															};
															node_bbox_aspect = node_bbox.width / node_bbox.height;
															rotate = bbox_aspect >= 1 && node_bbox_aspect < 1 || bbox_aspect < 1 && node_bbox_aspect >= 1;
															node.label_bbox = {
																x: bbox.x + (bbox.width - correct_x(bbox.width)) / 2,
																y: bbox.y + (bbox.height - correct_y(bbox.height)) / 2,
																width: correct_x(bbox.width),
																height: correct_y(bbox.height)
															};
															if (rotate) {
																node.label_bbox = {
																	x: node.label_bbox.y,
																	y: node.label_bbox.x,
																	width: node.label_bbox.height,
																	height: node.label_bbox.width
																};
																return d3.select(this).attr('transform', 'rotate(90) translate(0,1)');
															}
														});
														enter_labels.each(function (d) {
															d.iso_x = isometric([d.x + d.dx / 2, d.y + d.dy / 2, d.h + d.dh])[0] - d.dx / 2;
															return d.iso_y = isometric([d.x + d.dx / 2, d.y + d.dy / 2, d.h + d.dh])[1] - d.dy / 2;
														});
														enter_labels.attr({
															x: function (d) {
																return d.iso_x;
															},
															y: function (d) {
																return d.iso_y;
															},
															width: function (node) {
																return node.dx;
															},
															height: function (node) {
																return node.dy;
															},
															viewBox: function (node) {
																return "" + node.label_bbox.x + " " + node.label_bbox.y + " " + node.label_bbox.width + " " + node.label_bbox.height;
															},
															preserveAspectRatio: 'none',
															fill: function (d) {
																return d3.hcl(d.template_color.h, d.template_color.c, d.template_color.l - 12);
															}
														});
														enter_labels_g.attr({
															transform: function (d) {
																return "translate(" + (d.iso_x + d.dx / 2) + "," + (d.iso_y + d.dy / 2) + ") scale(1, " + (1 / Math.sqrt(3)) + ") rotate(-45) translate(" + (-(d.iso_x + d.dx / 2)) + "," + (-(d.iso_y + d.dy / 2)) + ")";
															}
														});
														enter_pipedons.append('path').attr({
															"class": 'iso outline',
															d: function (d) {
																return path_generator(d.iso.outline);
															}
														});
														return enter_pipedons.append('title').text(function (d) {
															return d.name;
														});
													});
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/tlfrd/fd6991b2d1947a3cb9e0bd20053899d6 */}}
													<h3 class="card-title">Stack-to-split transition chart - 1</h3>
												</div>
												<div class="card-body">
													<form>
														<label><input type="radio" name="s2s-mode" value="together" checked> together</label>
														<label><input type="radio" name="s2s-mode" value="split"> split</label>
													</form>
													<div id="stc1" style="height: auto"></div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var margin = {top: 20,right: 80,bottom: 80,left: 20},
														height = 460 - margin.top - margin.bottom,
														width = 712 - margin.left - margin.right;
														
													var data = {
														"assay_types": {
															"group_1": ["type_1", "type_2", "type_3",],
															"group_2": ["type_6", "type_7",],
															"group_3": ["type_9", "type_10", "type_11"]
														},
														"stages": [
															"1-cell",
															"2-cell",
															"4-cell",
															"16-cell",
															"32-cell",
															"64-cell",
															"128-cell",
															"256-cell",
															"512-cell",
															"1k-cell",
															"High",
															"Oblong",
															"Sphere",
															"Dome",
															"30%-epiboly",
															"50%-epiboly",
															"Germ-ring",
															"Shield",
															"75%-epiboly",
															"90%-epiboly",
															"Bud",
															"Prim-5",
															"Prim-15",
															"Prim-25",
															"High-pec",
															"Long-pec",
															"Day 5"
														],
														"data": [
															{"type_9": 10,"type_3":  3,"type_12": 20,"type_11": 12,"type_7":  1,"type_2": 1,"type_1":  1,"type_10": 12,"type_6":  1,"stage": "Oblong"},
															{"type_9": 10,"type_3":  6,"type_12": 22,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  2,"type_10": 11,"type_6":  1,"stage": "Bud"},
															{"type_9":  1,"type_3":  1,"type_12": 11,"type_11": 11,"type_7":  1,"type_2": 2,"type_1": 11,"type_10":  1,"type_6":  1,"stage": "Dome"},
															{"type_9": 10,"type_3": 10,"type_12": 21,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "Prim-25"},
															{"type_9": 10,"type_3": 10,"type_12": 20,"type_11":  1,"type_7": 11,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "High-pec"},
															{"type_9": 10,"type_3": 20,"type_12": 20,"type_11": 11,"type_7":  1,"type_2": 1,"type_1":  1,"type_10": 11,"type_6":  1,"stage": "High"},
															{"type_9": 10,"type_3": 13,"type_12": 20,"type_11": 12,"type_7":  3,"type_2": 1,"type_1":  1,"type_10": 12,"type_6":  7,"stage": "Shield"},
															{"type_9": 10,"type_3":  1,"type_12": 20,"type_11":  1,"type_7": 13,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "Germ-ring"},
															{"type_9":  3,"type_3": 10,"type_12":  3,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "128-cell"},
															{"type_9": 10,"type_3": 10,"type_12": 13,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "4-cell"},
															{"type_9": 10,"type_3": 10,"type_12":  8,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "32-cell"},
															{"type_9":  1,"type_3":  1,"type_12":  1,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  4,"stage": "Long-pec"},
															{"type_9": 10,"type_3": 10,"type_12": 11,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  2,"stage": "16-cell"},
															{"type_9": 10,"type_3": 10,"type_12": 23,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "1k-cell"},
															{"type_9": 10,"type_3": 10,"type_12": 20,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "1-cell"},
															{"type_9": 10,"type_3": 10,"type_12":  5,"type_11":  1,"type_7":  1,"type_2": 2,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "256-cell"},
															{"type_9": 10,"type_3": 13,"type_12": 12,"type_11":  1,"type_7":  2,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  7,"stage": "Sphere"},
															{"type_9": 10,"type_3":  5,"type_12": 23,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "90%-epiboly"},
															{"type_9": 10,"type_3": 15,"type_12": 20,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "2-cell"},
															{"type_9": 10,"type_3": 14,"type_12": 20,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6": 11,"stage": "Day 5"},
															{"type_9": 10,"type_3":  4,"type_12": 21,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "512-cell"},
															{"type_9": 10,"type_3": 11,"type_12": 14,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "30%-epiboly"},
															{"type_9": 10,"type_3":  2,"type_12": 28,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  3,"stage": "75%-epiboly"},
															{"type_9": 10,"type_3": 13,"type_12": 23,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "50%-epiboly"},
															{"type_9": 11,"type_3": 10,"type_12":  2,"type_11":  1,"type_7":  3,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "64-cell"},
															{"type_9": 10,"type_3": 10,"type_12": 20,"type_11":  1,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  1,"stage": "Prim-15"},
															{"type_9":  1,"type_3":  1,"type_12":  1,"type_11":  3,"type_7":  1,"type_2": 1,"type_1":  1,"type_10":  1,"type_6":  5,"stage": "Prim-5"}
														]
													};
													var assay_types = data.assay_types;

													function arrayAwareInvert(obj)
													{
														var res = {};
														for (var p in obj) {
															var arr = obj[p],
																l = arr.length;
															for (var i = 0; i < l; i++) {
																res[arr[i]] = p;
															}
														}
														return res;
													}

													var assay_types_inv = arrayAwareInvert(assay_types);

													var assays = [],
														assay_groups = [];

													for (var i in assay_types) {
														assay_types[i].map(function (item) {
															assays.push(item);
														});
													}
													for (var i in assay_types_inv) {
														assay_groups.push(assay_types_inv[i]);
													}

													var assay_groups_uniq = Object.keys(assay_types),
														n = assay_groups_uniq.length, //number of groups
														lastRow = (n - 1),
														spacing = {
															bottom: 15,
															right: 5
														},
														rowHeight = Math.floor((height - (n - 1) * spacing.bottom) / n);
													var x = d3.scaleBand()
														.rangeRound([0, width])
														.padding(0.1)
														.domain(data.stages);
													var y_split = d3.scaleLinear()
														.range([rowHeight, 0]);
													var y_stacked = d3.scaleLinear()
														.range([height, 0]);
													var z = d3.scaleBand().domain(assays).rangeRound([0, x.bandwidth()]);
													var color = d3.scaleOrdinal().domain(assays)
														.range(['#f03e3e', '#f76707', '#40c057', '#0ca678', '#1098ad', '#0b7285']);
													var color_shades = d3.scaleOrdinal().domain(assays)
														.range(['#69db7c', '#40c057', '#37b24d', '#2b8a3e',
															'#66d9e8', '#22b8cf', '#1098ad', '#0b7285',
															'#ffc9c9', '#ffa8a8', '#ff6b6b', '#f03e3e', '#c92a2a'
														]);
													var svg = d3.select("#stc1").append("svg")
														.attr("width", width + margin.left + margin.right)
														.attr("height", height + margin.top + margin.bottom)
														.append("g")
														.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
													var stack = d3.stack().keys(assays),
														layers = stack(data.data);
													
													layers.forEach(function (d, i) {
														d.forEach(function (dd) {
															dd.assay = assays[i];
															dd.assay_group = assay_groups[i];
														});
													});

													var ySplitMax = d3.max(layers, function (layer) {
														return d3.max(layer, function (d) {
															return d.data[d.assay];
														});
													}),
														yStackMax = d3.max(layers, function (layer) {
															return d3.max(layer, function (d) {
																return d[1];
															});
														});
													y_stacked.domain([0, yStackMax]).nice();
													y_split.domain([0, ySplitMax]).nice(5);

													// gridlines in y axis function
													function make_y_gridlines(scale, ticks)
													{
														return d3.axisLeft(scale).ticks(ticks);
													}

													// add the Y gridlines
													svg.append("g")
														.attr("class", "grid")
														.call(make_y_gridlines(y_stacked)
															.tickSize(-width)
															.tickFormat("")
														);
													

													var layer = svg.selectAll(".layer")
														.data(layers, function (d) {
															return assay_types_inv[d.key];
														})
														.enter().append("g")
														.attr("class", "layer")
														.attr("class", function (d) {
															return "layer " + assay_types_inv[d.key];
														});

													assay_groups_uniq.forEach(function (d) {
														svg.select("." + d)
															.append("g")
															.transition()
															.duration(300)
															.attr("class", "grid grid--split")
															.call(make_y_gridlines(y_split, 4)
																.tickSize(-width)
																.tickFormat("")
															)
															.attr('opacity', 0);
															
														svg.select("." + d)
															.append('g')
															.attr('class', 'axis--y')
															.attr('opacity', 0);
														svg.select("." + d)
															.append("g")
															.attr("class", "axis axes--x")
															.attr("transform", function () { return translate(0, rowHeight); })
															.attr('opacity', 0);
													});

													layer.append('g')
														.attr('class', 'axis--y')
														.attr('opacity', 0);
													layer.append("g")
														.attr("class", "axis axes--x")
														.attr("transform", function () { return translate(0, rowHeight); })
														.attr('opacity', 0);

													var bars = layer.selectAll("rect")
														.data(function (d) { return d; }, function (d) { return d.key; })
														.enter().append("rect")
														.style("fill", function (d) { return color_shades(d.assay); })
														.attr("x", function (d) { return x(d.data.stage); })
														.attr("y", function () { return height; })
														.attr("width", x.bandwidth())
														.attr("height", function () { return 0; })
														.attr("class", function (d) { return "bar " + d.assay; })

													bars.transition()
														.delay(function (d, i) { return i * 10; })
														.attr("y", function (d) { return y_stacked(d[1]); })
														.attr("height", function (d) { return y_stacked(d[0]) - y_stacked(d[1]); });

													var legend = svg.selectAll(".legend")
														.data(assays)
														.enter().append("g")
														.attr("class", "legend")
														.attr("transform", function (d, i) {
															return "translate(30," + i * 20 + ")";
														});

													legend.append("rect")
														.attr("x", width - 14)
														.attr("width", 14)
														.attr("height", 14)
														.style("fill", function (d) {
															return color_shades(d);
														})
														.on("mouseover", function (d) {
															svg.selectAll(".bar:not(." + d.replace(" ", "_") + ")")
																.style('opacity', '0.1');
														})
														.on("mouseout", function (d) {
															svg.selectAll(".bar:not(." + d.replace(" ", "_") + ")")
																.style('opacity', '1');
														});

													legend.append("text")
														.attr("x", width + 5)
														.attr("y", 8)
														.attr("dy", ".35em")
														.style("text-anchor", "start")
														.style("font-size", "12px")
														.text(function (d) {
															return d;
														})
														.on("mouseover", function (d) {
															svg.selectAll(".bar:not(." + d.replace(" ", "_") + ")")
																.transition()
																.duration(100)
																.style('opacity', '0.25');
														})
														.on("mouseout", function (d) {
															svg.selectAll(".bar:not(." + d.replace(" ", "_") + ")")
																.transition()
																.duration(500)
																.style('opacity', '1');
														});

													svg.append("g")
														.attr("class", "axis axis--x")
														.attr("transform", "translate(0," + height + ")")
														.call(d3.axisBottom(x).tickSizeOuter(0))
														.selectAll("text")
														.attr("dx", "-0.35em")
														.attr("dy", "0.6em")
														.attr("transform", "rotate(-45)")
														.style("text-anchor", "end");
													svg.append("g")
														.attr("class", "axis axis--y axis--stacked")
														.call(d3.axisLeft(y_stacked).ticks(10))
														.append("text")
														.attr("x", 6)
														.attr("y", -10)
														.attr("dy", "0.35em")
														.attr("text-anchor", "start")
														.attr("fill", "#000")
														.text("counts");

													d3.selectAll("input[name=s2s-mode]").on("change", function (){
														if (this.value === "split") {
															transitionSplit();
														} else if (this.value === "together") {
															transitionStacked();
														}
													});

													function translate(x, y)
													{
														return "translate(" + x + ", " + y + ")";
													}

													function rowPosition(d)
													{
														return assay_groups_uniq.indexOf(assay_types_inv[d.key]);
													}

													function transitionSplit()
													{
														var g = svg.selectAll(".layer")
															.transition().duration(750)
															.attr("transform", function (d) {
																return translate(0, rowPosition(d) * (rowHeight + spacing.bottom));
															});

														svg.selectAll('g.grid')
															.attr('opacity', 0);
														layer.selectAll('g.grid--split')
															.attr('opacity', 1)
															.transition()
															.duration(750);

														g.selectAll("rect")
															.attr("y", function (d, i) {
																return y_split(d.data[d.assay]);
															})
															.attr("height", function (d) {
																return rowHeight - y_split(d.data[d.assay]);
															});

														layer.selectAll('.axes--x')
															.transition()
															.duration(750)
															.attr('opacity', 1)
															.call(d3.axisBottom(x).tickSize(0))
															.selectAll("text")
															.attr('opacity', 0);

														layer.selectAll('.axis--y')
															.transition()
															.duration(750)
															.attr('opacity', 1)
															.call(d3.axisLeft(y_split).ticks(3));

														svg.selectAll('g.axis--stacked')
															.attr('opacity', 0);
													}

													function transitionStacked()
													{
														var t = svg.transition().duration(750),
															g = t.selectAll(".layer")
																.attr("transform", function () {
																	return translate(0, 0);
																});
														g.selectAll("rect")
															.attr("y", function (d) {
																return y_stacked(d[1]);
															})
															.attr("height", function (d) {
																return y_stacked(d[0]) - y_stacked(d[1]);
															});
														layer.selectAll('.axes--x')
															.attr('opacity', 0);
														layer.selectAll('.axis--y')
															.transition()
															.duration(750)
															.attr('opacity', 0);
														svg.selectAll('g.grid')
															.transition()
															.duration(750)
															.attr('opacity', 1);
														layer.selectAll('g.grid--split')
															.transition()
															.duration(750)
															.attr('opacity', 0);

														svg.selectAll('g.axis--stacked')
															.transition()
															.duration(300)
															.attr('opacity', 1);
													}
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* http://blockbuilder.org/allyraza/417e4fad5cbec29b9c3a64a7a1cc1445 */}}
													<h3 class="card-title">Realtime line chart</h3>
												</div>
												<div class="card-body">
													<div id="rtc1" style="height: 300px;">
													</div>
												</div>
											</div>
											<script>
												require(['d3'], function (d3) {
													var data = [
														{ x: 10, y: 10, z: 10 },
														{ x: 10, y: 10, z: 10 },
														{ x: 10, y: 10, z: 10 },
														{ x: 10, y: 10, z: 10 },
														{ x: 10, y: 10, z: 10 },
														{ x: 10, y: 10, z: 10 },
													];

													var width = 200;
													var height = 100;
													var globalX = 0;
													var duration = 500;
													var step = 10;
													var max = 10;
													var chart = d3.select('#rtc1')
														.append('svg')
														.attr('width', width + 10)
														.attr('height', height + 10);

													var x = d3.scaleLinear().domain([0, width]).range([0, width]);
													var y = d3.scaleLinear().domain([0, height]).range([height, 0]);

													var defs = chart.append('defs');

													var gradient = defs.append("linearGradient")
														.attr("id", "areaGradient")
														.attr("x1", "100%")
														.attr("x2", "100%")
														.attr("y1", "0%")
														.attr("y2", "100%");

													gradient.append("stop")
														.attr('class', 'start')
														.attr("offset", "0%")
														.attr("stop-color", "#5b85c9")
														.attr("stop-opacity", 1);

													gradient.append("stop")
														.attr('class', 'end')
														.attr("offset", "100%")
														.attr("stop-color", "#5b85c9")
														.attr("stop-opacity", 0);

													var line = d3.line()
														.x(d => x(d.x))
														.y(d => y(d.y))
														.curve(d3.curveCatmullRom.alpha(0.5));

													var targetLine = d3.line()
														.x(d => x(d.x))
														.y(d => y(d.z))
														.curve(d3.curveCatmullRom.alpha(0.5));

													var areaLine = d3.area()
														.x(d => x(d.x))
														.y0(height)
														.y1(d => y(d.y));

													// Append the holder for line chart and fill area
													var path = chart.append('path');
													var targetPath = chart.append('path');
													var areaPath = chart.append('path');

													var rand = (min, max) => Math.random() * (max - min) + min;

													// Draw
													function draw(value, target)
													{
														var point = { x: globalX, y: value, z: target, };

														data.push(point);
														globalX += step;

														// Draw new line
														path.datum(data)
															.attr('class', 'line')
															.attr('d', line)
															.attr("fill", "none")
															.attr("stroke", "#5b85c9")
															.attr("stroke-width", "1.5px");
														targetPath.datum(data)
															.attr('class', 'line-default')
															.attr('d', targetLine)
															.attr("fill", "none")
															.attr("stroke", "#5b85c9")
															.attr("stroke-dasharray", "3,3")
															.attr("stroke-width", "1.5px");
														areaPath.datum(data)
															.attr('class', 'area')
															.attr('fill', 'url(#areaGradient)')
															.attr('d', areaLine)
															.attr("opacity", "0.5");

														// Shift the chart left
														if (globalX > width) {
															x.domain([globalX - (width - step), globalX]);
														}

														path.attr('transform', null)
															.transition()
															.duration(duration)
															.attr('transform', 'translate(' + x(globalX - max) + ')');

														targetPath.attr('transform', null)
															.transition()
															.duration(duration)
															.attr('transform', 'translate(' + x(globalX - max) + ')');

														areaPath.attr('transform', null)
															.transition()
															.duration(duration)
															.attr('transform', 'translate(' + x(globalX - max) + ')');

														if (data.length > 50) data.shift();
													}

													setInterval(function () {
														draw(rand(50, 100), rand(40, 80));
													}, 1000);

													// (function () {
													// 	var data = document.getElementById("fileData");
													// 	var conn = new WebSocket("ws://{{.Host}}/ws");
													// 	conn.onclose = function (evt) {
													// 		console.log('Connection closed');
													// 	}
													// 	conn.onmessage = function (evt) {
													// 		draw(JSON.parse(evt.data).value)
													// 	}
													// })();
												});
											</script>
										</div>
									</div>
								</div>
								{{/* chart-end */}}
								{{/* chart-start */}}
								<div class="card">
									<div class="card-body">
										<div class="text-wrap p-lg-6">
											<div class="card">
												<div class="card-header">
													{{/* url */}}
													<h3 class="card-title">Doodle</h3>
												</div>
												<div class="card-body">
													<div id="doodle1" style="height: auto"></div>
												</div>
											</div>
										</div>
									</div>
								</div>
								<script>
									require(['d3'], function (d3) {
										var data = [59,21,16,30,49,2,10,17,1,24,55,24,26,51,45,0,21,16,54,5,43,11,10,4,25,43,14,26,25,45,40,37,47,16,2,12,31,38,9,34,5,13,27,8];
										var chart = d3.select('#doodle1')
											.append('svg')
											.attr('width', 712)
											.attr('height', 80);
										data.map(function (d, i) {
											chart.append("rect")
												.attr("rx", "4")
												.attr("opacity", "0.75")
												.attr("x", 4 + 16 * i)
												.attr("y", 60 - d + 4)
												.attr("height", d)
												.attr("width", "6")
												.attr("fill", function(data) {
													if (d > 40) return "rgb(255, 39, 24)";
													if (d > 20) return "#ffad5b";
													return "#57c472";
												});
											chart.append("rect")
												.attr("rx", "8")
												.attr("opacity", "0.25")
												.attr("x", 16 * i)
												.attr("y", 60 - d)
												.attr("height", d + 8)
												.attr("width", "14")
												.attr("fill", "#a2dbf0");
										});
									});
								</script>
								{{/* chart-end */}}
							</div>
						</div>
						{{/* http://blockbuilder.org/tlfrd/dfee3b6061e50ad73d9df7a7a73b68e9 */}}
						{{/* http://123.207.84.88:8008/bar-chart3-v4.html */}}
{{ end }}
